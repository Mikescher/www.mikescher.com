<Query Kind="Program">
  <Namespace>System.CodeDom.Compiler</Namespace>
  <Namespace>System.CodeDom</Namespace>
</Query>

Encoding ENC = new UTF8Encoding(false);

void Main()
{
	Do(1, "Multiples of 3 and 5", "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\r\n\r\nFind the sum of all the multiples of 3 or 5 below 1000.", "vvv:           <           <\r\n1> 1+:::3/3*-!#^_>::5/5*-!#^_v\r\n1$v          ># v#      ># v#<\r\n1 >:5558***-!|v$<>+\\:1-!|v$<\r\n>^           <>$$^\\     <>.@", "The solution here is pretty straight-forward, going through all numbers from 1-1000 and adding all multiples of 3 and 5 together. ", 0, 47624, 62, 30, 5, 233168);
	Do(2, "Even Fibonacci numbers", "Each new term in the Fibonacci sequence is generated by adding the previous two terms.\r\nBy starting with 1 and 2, the first 10 terms will be:\r\n\r\n~~~\r\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\r\n~~~\r\n\r\nBy considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.", "v>v>ppp 0>>$ 10g20g:10p+:v\r\n202 >00p0^|-*2/2::<  vp02<\r\n0::0^+ g00<v**\"}P  \":<\r\n:1>^@$.g00<>*` #v_^\r\n>^        ^     <", "Also the problem here was not the algorithm, but writing and compressing it in Befunge. The code calculates the Fibonacci sequence one after each other and remembers the sum while iterating.", 0, 1669, 62, 26, 5, 4613732);
	Do(3, "Largest prime factor", "The prime factors of 13195 are 5, 7, 13 and 29.\r\n\r\nWhat is the largest prime factor of the number 600851475143 ?", "89197939490919v          >00g10g1-:10p%#v_10g:30p1-40pv\r\nv+*29191929891<          ^    <         <_v#!  %g04g03<\r\n>*+*+*+*+*+*+*v >\"{.i \"+**10p#^ #p #0 #0 <>40g:1-40p2-|\r\n              >#^ +# *# +# *# +# *# +# *# +#    <@.g03<", "This problem is the reason why I changed the internals of my interpreter to int64 (because the numbers are too big for int32).\r\n\r\nFortunately the number is still small enough to brute-force the prime factors, going from the biggest factor to the smallest, the first factor (that is also a prime) that my code finds is the solution.", 0, 31579516, 9547, 55, 4, 6857);
	Do(4, "Largest palindrome product", "A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\r\n\r\nFind the largest palindrome made from the product of two 3-digit numbers.", "1:010:pp5558***04p>10g1+::10p04g-00g \\#v_1+:00p\\$1:10p\\:04g- #v_$$03g.@\r\n                  ^         v $<       >1# 0# 1# p# *# :# v#  <\r\n   v_v#-g1-g20g10g 1g20<p201<v_^#:/+55p10+1g10p1g10%+55:  <\r\n   $ >02g1+:02p 01 g - |     >                            ^\r\n   >              ^    >:03g\\`#v_03pv\r\n                  ^           $<   0<", "Again we can write our program fast enough to brute-force the solution. So we iterate through every possible 3-digit product and check if its a palindrom.", 0, 230611114, 77813, 71, 6, 906609);
	Do(5, "Smallest multiple", "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\r\n\r\nWhat is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?\r\n", "45*00p110p120p >10g20g*10p00g20g1+:20p`#v_10g.@ \r\n               ^_v#`g00p03+1:g03   <p031<         v <\r\n                 >10g30g%          |1              <^        p01/g03g01< \r\n                                   >10g30g/40p150p  > 20g50g1+:50p` #v_^\r\n                 ^                                < |!%g05g04        <\r\n                                                   ^<", "We start with a value of `1`.\r\nThen we multiply one after another the numbers from `1` to `20` to our value (We call these `multiplicand` in the loop).\r\n\r\nAfter each multiplications we search go through the numbers from `2` to `value` and search for a number `divisor` where\r\n\r\n - `value % divisor == 0`\r\n - `(value / divisor) % {0, multiplicand} == 0`\r\n\r\nThen (after we found such a number) we can reduce the value with it (`value /= divisor`).\r\n\r\nThe reduction steps guarantees us that we find the **smallest** number and it prevents our *Int64* numbers from overflowing", 0, 50166, 47, 73, 6, 232792560);
	Do(6, "Sum square difference", "The sum of the squares of the first ten natural numbers is,\r\n`1^2 + 2^2 + ... + 10^2 = 385`\r\n\r\nThe square of the sum of the first ten natural numbers is,\r\n`(1 + 2 + ... + 10)^2 = 552 = 3025`\r\n\r\nHence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is `3025 - 385 = 2640`.\r\n\r\nFind the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.", "\"d\"10p000p>10g:00g+00p1-:#v_$010p>\"c\"10g::1+:*\\:5:+%\\5:+/6+p`#v_       v\r\n>$.@      ^            p01<      ^                   p01+1g01 <        0\r\n     >                                   v\r\n|!:\\<|p01-1:g01<$$_v#!:g+6/+:5\\%+:5:g01 :< p01\"c\"+<_v#!p01:-1g01<p01:g0<\r\n\\   ^<             >` >                 #v_v\r\n>         v            v-g+6/+:5\\%+:5:g01<          >00g        ^\r\n##########>                                       ^\r\n##########             >010g:5:+%\\5:+/6+pv\r\n##########                                \r\n##########     ^                         < <\r\n##########\r\n##########\r\n##########\r\n##########\r\n##########\r\n##########", "My solution here is *far* more complex than necessary, mostly because I thought the temporary numbers would get too big for int32 to handle (especially sum(1,100)^2).\r\nLater I found out I could just calculate the sum of the squares and the square of the sum and subtract them ...\r\n\r\nBut I like my solution so I\'ll leave it here.\r\nWhile I calculate the the second value (using the distributive property), I subtract in every step as much parts of the first value (the single elements of the addition) as I can (without going negative).\r\n\r\nThat way my temporary values never greatly exceed the final result.", 0, 18897151, 7347, 72, 16, 25164150);
	Do(7, "10001st prime", "By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\r\n\r\nWhat is the 10 001st prime number?", "v\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n                                                                             v                                <\r\n>\"d\"55+*:10p3\"2\"*:20p*00p230p\" \":01p11p10g5:+*1+50pv              > 030p 040p>30g1+:30p:10g%\\10g/1+g\"X\"-      |\r\nv                                                  <             _^#`g03g00 <|p+1/g01\\%g01:g03\"0\"-p04:+1g04g05<\r\n> \"X\" 30g:10g%\\10g/1+p30g >30g+ : 00g\\`     #v_$>30g1+:30p:10g%\\10g/1+g\" \"- |>30g.@\r\n                          ^p+1/g01\\%g01:\\\" \":<  ^                           <", "Finally a opportunity to use my favorite algorithm: [The sieve of Eratosthenes.](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)", 1, 21915385, 7628, 1000, 156, 104743);
	Do(8, "Largest product in a series", "The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.\r\n\r\n```\r\n...\r\n```\r\n\r\nFind the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?\r\n", "\"v\"00p54*:10p552**:20p*30p85+40p050p060p070p080p    v\r\n>150g60p>60g:20g%\\20g/9+g\"0\"-*60g1+:60p50g-40g-#v_:80g`#v_$>50g1+:50p30g-#v_ 970p >70g0g.70g8-40g-#v_\"=\",80g.@\r\n        ^                                       <   $      ^                                                       <\r\n                                                        >80p060p>60g50g+:2 0g%\\20g /9+g\"0\"-60g9+0p6 0g1+:60p40g-#v_^\r\n^                                                   <                     <       ^p07+1g07        <              \r\n                                                                ^                                                <\r\n\r\n\r\n\r\n73167176531330624919225119674426574742355349194934\r\n96983520312774506326239578318016984801869478851843\r\n85861560789112949495459501737958331952853208805511\r\n12540698747158523863050715693290963295227443043557\r\n66896648950445244523161731856403098711121722383113\r\n62229893423380308135336276614282806444486645238749\r\n30358907296290491560440772390713810515859307960866\r\n70172427121883998797908792274921901699720888093776\r\n65727333001053367881220235421809751254540594752243\r\n52584907711670556013604839586446706324415722155397\r\n53697817977846174064955149290862569321978468622482\r\n83972241375657056057490261407972968652414535100474\r\n82166370484403199890008895243450658541227588666881\r\n16427171479924442928230863465674813919123162824586\r\n17866458359124566529476545682848912883142607690042\r\n24219022671055626321111109370544217506941658960408\r\n07198403850962455444362981230987879927244284909188\r\n84580156166097919133875499200524063689912560717606\r\n05886116467109405077541002256983155200055935729725\r\n71636269561882670428252483600823257530420752963450", "These kinds of problems are fun in Befunge because you can just copy the input into your program and it becomes a part of your source code.", 0, 614295, 234, 116, 29, 23514624000);
	Do(9, "Special Pythagorean triplet", "A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\r\n`a^2 + b^2 = c^2`\r\n\r\nFor example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.\r\n\r\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000.\r\nFind the product abc.", "\"d\"5:+*00p210p>   120p>v                >20g1+:20p10g-#v_10g1+:10p00g-#v_ @\r\n                      ^                                <\r\n              ^                                                        <\r\nv                      <                 \r\n>20g:*10g:*+:30p0>::*30g-#v_:30p20g10g++ 00g-#v_20g:.\" \",10g:.\" \",30g:.\"=\",**.@\r\n                 |-g00 :+1<                   \r\n                 >$$                    ^    $<", "The brute-force approach is here taking quite a long time - but I think it\'s good enough - perhaps I will make an optimized version later", 0, 1397212134, 394277, 79, 7, 31875000);
	Do(10, "Summation of primes", "The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\r\n\r\nFind the sum of all the primes below two million.\r\n", "v\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n>\"d\"55+*:2**1- >:\"#\"\\:\"d\"55+2**%\\\"d\"55+2**/1+p:#v_ \"d\"55+*:2*:10p                          v\r\n^              ^                              -1<  v p05+1*+:5g01p11p10:\" \"p032p00*p02:    <v            <\r\n                                                                  > 030p 040p>30g1+:30p:10g% \\10g/1+g\"X\"-|\r\nv                                                  <             _^#`g03g00 <|     - g03g00 < p04+g04 g03<\r\n> \"X\" 30g:10g%\\10g/1+p30g >30g+ : 00g\\`     #v_$>30g1+:30p:10g%\\10g/1+g\" \"- |>40g.@\r\n                          ^p+1/g01\\%g01:\\\" \":<  ^                           <", "And again a sieve of Eratosthenes (see Problem 7), but this time a lot bigger.", 1, 416776174, 67127, 2000, 1007, 142913828922);
	Do(11, "Largest product in a grid", "In the 20×20 grid below, four numbers along a diagonal line have been marked in red.\r\n\r\n```\r\n...\r\n```\r\n\r\nThe product of these numbers is 26 × 63 × 78 × 14 = 1788696.\r\n\r\nWhat is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?", "v             v                                             <\r\n>\"4\"2/:*1-00p > 000g: \"4\"2/ %\"?\"+\\ \"4\"2/ /1+ p  00g:1-00p  #^_v++++++++++++++++++++++++++\r\n                                                               ++++++++++++++++++++++++++\r\n                                                               ++++++++++++++++++++++++++\r\n 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 | +++####################+++\r\n 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 | +++####################+++\r\n 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 | +++####################+++\r\n 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 | +++####################+++\r\n 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 | +++####################+++\r\n 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 | +++####################+++\r\n 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 | +++####################+++\r\n 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 | +++####################+++\r\n 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 | +++####################+++\r\n 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 | +++####################+++\r\n 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 | +++####################+++\r\n 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 | +++####################+++\r\n 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 | +++####################+++\r\n 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 | +++####################+++\r\n 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 | +++####################+++\r\n 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 | +++####################+++\r\n 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 | +++####################+++\r\n 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 | +++####################+++\r\n 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 | +++####################+++\r\n 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48 | +++####################+++\r\nvp00-1*:*45    p1++1550p0++1551p1+55-10p0+551p19-10p090   p010<++++++++++++++++++++++++++                     >10pv\r\n>00g:54*%3*1+\\54*/4+g\"0\"-52**00g:54*%3*2+\\54*/4+g\"0\"-+00g:54*%v++++++++++++++++++++++++++                       >$>     v\r\n|                                        p00-1:g00p+4/*45\\+\"B\"<++++++++++++++++++++++++++                     ^_^#`g01:<     v                 <\r\n>54*:*1-00p>220p>20g9+:0g30p1g40p00g:54*%50p54*/60p50g\"B\"+60g4+g50g30g+50p60g40g+60p>50g\"B\"+60g4+g50g30g+50p60g40g+60pv >20g:1-20p#v_00g:1-00p#^_10g. @\r\n           ^   _^#                                                                 <vp06+g04g06p05+g03g05g+4g06+\"B\"g05<^ <  v     0< \r\n                                                                                    >50g\"B\"+60g4+g50g30g+50p60g40g+60p***^ \r\n                                                                                   ^                                        <<", "The idea here was to first move the numbers into a *real* 20x20 grid where every field represents a single number, the rest was not that hard.", 0, 323945, 78, 151, 31, 70600674);
	Do(12, "Highly divisible triangular number", "The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\r\n\r\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\r\n\r\nLet us list the factors of the first seven triangle numbers:\r\n\r\n 1: 1  \r\n 3: 1,3  \r\n 6: 1,2,3,6  \r\n10: 1,2,5,10  \r\n15: 1,3,5,15  \r\n21: 1,3,7,21  \r\n28: 1,2,4,7,14,28    \r\n\r\nWe can see that 28 is the first triangle number to have over five divisors.\r\n\r\nWhat is the value of the first triangle number to have over five hundred divisors?", "# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n                                                                             v  p03+1g03 p04+1g04   p +3/g01\\%g01:g04 g03 <\r\n>\"d\"55+*:10p3\"2\"*:20p*00p230p\" \":03p13p            v              >130p040p  > 30g:10g%\\10g/3+g\" \"- 00g30g` !#v_          |\r\nv                                                  <             _^#`g03g00 <^                        p03+1g03            <\r\n> \"X\" 30g:10g%\\10g/3+p30g >30g+ : 00g\\`     #v_$>30g1+:30p:10g%\\10g/3+g\" \"- |                                 \r\n                          ^p+3/g01\\%g01:\\\" \":<  ^                           <\r\n                                   v                                                            +1$<\r\n                >:1+2/>:01p31p111p0>::10g%\\10g/3+g::*01g`#v_121p>:31g\\%         !#v_11g21g*11p31g1-|\r\n                                                  v        <    ^p13/\\g13:p12+1g12<                \r\n            v                      <          vp21<*2g11$$<^g11$$                                  <\r\n>2 212p222p >:2%|                             >12g22g*\"d\"5*` #v_1+    1v\r\n                                   |                                   <                       0+1$<\r\n                >:1+  >:01p31p111p0>::10g%\\10g/3+g::*01g`#v_121p>:31g\\%         !#v_11g21g*11p31g1-|\r\n                                              #   v        <  v ^p13/\\g13:p12+1g12<                \r\n                                              ^p22<*2g11$$<^g11$$                                  <\r\n                                                              >$$:1+*2/.@\r\n^                                                                                                    $p05-1g04<", "Here I was desperately in need of an efficient algorithm. So I copied [this](http://www.mathblog.dk/triangle-number-with-more-than-500-divisors/) one from mathblog.dk and translated it into befunge. And I have to say it\'s amazingly fast.", 1, 38855123, 7566, 1000, 170, 76576500);
	Do(13, "Large sum", "Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.\r\n\r\n```\r\n...\r\n```", "v     // Project Euler - Problem 13\r\n      37107287533902102798797998220837590246510135740250\r\n      ...\r\n#     53503534226472524250874054075591789781264330331690\r\n=\r\n\r\n         v_v#                   <               <1<\r\n>510p\"d\"20p>\"0\"10g20gp10g1-:10p#^_510p20g1-:20p#^_^\r\nv       $<\r\n>\"7\"10pv>10g20gg\" \"-!#v_       >10g20gg\"0\"-00g+00p v\r\nv30p021< >10g1-10p55+/00p   v  |-\" \"gg02g01p02+1g02<\r\n>0p0::p ^^p021pg02g01+\"0\"%+55:<>0v\r\n        ^             \"#   $< ^g0<\r\nv          p02\"e\"p010$<\r\n>10g1+:10p20gg\"0\"-!#v_55+00p>00g:1-00p!#@_54+00g-10g+20gg,v\r\n^                   <       ^                             <", "Here I do simply do a column addition. After the sum is calculated, we take the first 10 digits and print them", 1, 244792, 78, 59, 113, 5537376230);
	Do(14, "Longest Collatz sequence", "The following iterative sequence is defined for the set of positive integers:\r\n\r\nn -> n/2 (n is even)\r\nn -> 3n + 1 (n is odd)\r\n\r\nUsing the rule above and starting with 13, we generate the following sequence:\r\n13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1\r\n\r\nIt can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.\r\n\r\nWhich starting number, under one million, produces the longest chain?\r\n\r\nNOTE: Once the chain starts the terms are allowed to go above one million.", "v               >3*1+v\r\n>0::p3>1+:1\\>:2%|    >\\1+\\:1- #v_$:00g\\`#v_00p:10pv\r\nv:0.g0 1<   ^  $># 2/^#1       <         $\r\ng     ^_^#!`  **\"}}@\":                   <        <\r\n>\": \",,.@", "Again a simple problem, we get the length of every sequence (= until they reach `1`) and print the highest.", 0, 3877209672, 717713, 51, 5, 837799);
	Do(15, "Lattice paths", "Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.\r\n\r\n![Grid Image](/data/blog/Befunge/p015.gif)\r\n\r\nHow many such routes are there through a 20×20 grid?", "v\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000\r\n 000000000000000000000              >                                        v\r\n                        >v                        >00g1-10gg00g10g1-g+00g10gpv                                  \r\n>100p110p> 00g492*+10g-*|>00g392*+`#^_>00g1-10g1-*|         vp01+1g01p00-1g00<\r\n         ^p011p00+g01g00<                         >100g10gp                  ^                  \r\n         |!  `+2*58+g00g01                                  <\r\n  @.g:*73<", "We create a 21x21 grid of the edges in our graph, then we set the value on each edge to the number of possible paths to (0|0).  \r\nFor the top-left edge this is `1`. For the edges in the first row/column it is also `1`. For every other edge it is the above edge + the left edge.  \r\nAnd in the end we are only interested in the value of the bottom-right edge - this value is our result.", 0, 61202, 47, 78, 27, 137846528820);
	Do(16, "Power digit sum", "2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.\r\n\r\nWhat is the sum of the digits of the number 2^1000?", "v00000000000000000000000000000000000000000000000000000000000\r\nv00000000000000000000000000000000000000000000000000000000000\r\nv00000000000000000000000000000000000000000000000000000000000\r\nv00000000000000000000000000000000000000000000000000000000000\r\nv00000000000000000000000000000000000000000000000000000000000\r\nv00000000000000000000000000000000000000000000000000000000001\r\n\r\n> \"0\":::::00p01p02p03p04p05p v  // INIT\r\nv  p64*8\"}\"p60*p62:6p61:\"<\"  <v p66-1g66                <\r\n       >06g1-66p             0> 66g16g%66g16g/g\"0\"-+ 66g|\r\nv      $#                            <                  .\r\n>46g:!#^_ 1-46p 06g1-66p 076p > 66g!#^_  v              @\r\nv61g66+\"0\"%+55:+g67*2-\"0\"g/g61 g66%g61g66<\r\n>g%66g16g/p55+/76p 66g1-66p   ^", "Here I implemented a long multiplication algorithm. Then I took the value `1` and doubled it 1000 times. The calculation of the digit sum was then easy.", 0, 27332672, 4228, 60, 14, 1366);
	Do(17, "Number letter counts", "If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.\r\n\r\nIf all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?\r\n\r\n*NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of \"and\" when writing out numbers is in compliance with British usage.*", "v\r\n033544355436688779886\r\n0366555766\r\n$\r\n$   v-1           <    v-1          <\r\n>54*>:::1g\"0\"-\\1p#^_54*>:::2g\"0\"-\\2p|\r\nv                       **25\"d\" 0 $$<\r\nv                                              <\r\n   v            $<   >:55+/2g\\55+%           v      \r\n:              >:54*`|         >\"d\"/1g70     v      \r\n>0\\>:!#v_:\"d\"\\`| ^0g1<  >:\"d\"%!|        v    <     \r\nv      <       >:\"}\"8*-#^_$380v>:\"d\"/1g\\ \"d\"%v  \r\n   ^                          <         <\\3\\7< \r\n>+# \\:# _+          \\ 1-                      :|\r\n                                 @.+_ #! #:\\ #+<", "There are only `N` kinds of numbers: \r\n\r\n- `0` - `20`: Get the length from a precomputed list\r\n- `20` - `99`: Get the length of the first word from a precomputed list and the length of the second word (second digit) from the previous point\r\n- `100` - `999`: Get the length of the first word from a precomputed list and the length of the second and third word (second digit) from the previous point\r\n- `1000`: Get the hard coded value\r\n\r\n*Note*: Interestingly this program operates completely on the stack - only the initializing method sets a few \"constant fields\" to per-definied values", 0, 179076, 47, 48, 15, 21124);
	Do(18, "Maximum path sum I", "By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.\r\n\r\n~~~\r\n3\r\n7 4\r\n2 4 6\r\n8 5 9 3\r\n~~~\r\n\r\nThat is, 3 + 7 + 4 + 9 = 23.\r\n\r\nFind the maximum total from top to bottom of the triangle below:\r\n\r\n~~~\r\n...\r\n~~~\r\n\r\n*NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)*", "$$>53* 00p00g1-20p010p>10g3*:20g1+g\"0\"-55+*\\1+20g1+g\"0\"-+10g20g1+p10g1+:10p20g-1-#v_20g:1-20p010p#v_v\r\n75                    ^                                                           <               < v\r\n95 64                 v                                                                             <\r\n17 47 82                                                                 > $v\r\n18 35 87 10           >00g2-:10p20p>10g20g1+g10g20g2+g:10g1+20g2+g -:0`>#^_->+10g20g1+p10g:1-10p#v_20g:1-:20p10p#v_01g.@\r\n20 04 82 47 65                     ^                                                             <               <\r\n19 01 23 75 03 34\r\n88 02 77 73 07 63 67\r\n99 65 04 28 06 16 70 92\r\n41 41 26 56 83 40 80 70 33\r\n41 48 72 33 47 32 37 16 94 29\r\n53 71 44 65 25 43 91 52 97 51 14\r\n70 11 33 28 77 73 17 78 39 68 17 57\r\n91 71 52 38 17 14 91 43 58 50 27 29 48\r\n63 66 04 68 89 53 67 30 73 16 69 87 40 31\r\n04 62 98 27 23 09 70 98 73 93 38 53 60 04 23", "Step 1: Convert the numbers so that 1 field  = 1 number\r\n\r\nStep 2: Set every field to `value` + max(`value-left`, `value-right`)\r\n\r\nStep 3: The solution is the value of the top-most field", 0, 15048, 16, 120, 16, 1074);
	Do(19, "Counting Sundays", "You are given the following information, but you may prefer to do some research for yourself.\r\n\r\n - 1 Jan 1900 was a Monday.\r\n - Thirty days has September,\r\n - April, June and November.\r\n - All the rest have thirty-one,\r\n - Saving February alone,\r\n - Which has twenty-eight, rain or shine.\r\n - And on leap years, twenty-nine.\r\n - A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.\r\n\r\nHow many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?", "v303232332323\r\nv313232332323\r\n6\r\n>2*>::0g\"0\"-47*+\\0p::v\r\n   |:-1p1\\+*74-\"0\"g1 <\r\nv $<\r\n>202p112p122p\"2&\"*1+32p092pv\r\nv20+1g20p29+g29!+-1g21%7g20<>#       0# v#   <      >                 >v\r\n>p12g1+12p32g4%             |       >1 >>22g\\g12g1--|\r\n                            >32g\"d\"%|  0^ <  #      >112p22g:1+22p66+-| \r\n                          v%*4\"d\"g23<>#^_1^  |-+1*\"(2\"g23<p23+1g23p221< \r\n                          >          ^>1^    >92g.@      ^             <", "In the first two rows we remember the day-count of each month.\r\nFirst row is normal years, second row leap years.\r\nThen we just enumerate through all days and test if its a Sunday and the first of month.", 0, 3197878, 546, 72, 12, 171);
	Do(20, "Factorial digit sum", "n! means n × (n - 1) × ... × 3 × 2 × 1\r\n\r\nFor example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,\r\nand the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\r\n\r\nFind the sum of the digits in the number 100!", "v00 ... 00\r\nv00 ... 01\r\n>\"d\">1-:!#v_:03p013p\"~I\"+23p>23g\"d\"%1+23g\"d\"/g\"0\"-03g*13g+:55+%68 v\r\n    ^     $#               _^#!p32:-1g32p31/+55p/\"d\"g32+1%\"d\"g32+*<\r\n          >\"~I\"+33p0>33g\"d\"%1+33g\"d\"/g\"0\"-+  33g:1-33p v\r\n                 @._^#!                                <", "The approach is similar to problem 16 - the main task was implementing a long multiplication algorithm in Befunge. \r\nThen, after 100! is calculated we only need to sum the individual digits.", 1, 1546679, 265, 101, 6, 648);
	Do(21, "Amicable numbers", "Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).\r\nIf d(a) = b and d(b) = a, where a ? b, then a and b are an amicable pair and each of a and b are called amicable numbers.\r\n\r\nFor example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.\r\n\r\nEvaluate the sum of all the amicable numbers under 10000.", "v\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n                                v       >#        v#   <\r\n>\"d\"4*:10p55**00p00g>1-::20p0\\2/>:20g\\%#^_:30p+30g>1-:#^_$v\r\n                    |:                   p+1/g01g02%g01g02<\r\nv$$             p100< \r\n>00g1-20p090p>20g10g%20g10g/1+g40p40g10g%40g10g/1+g50p 20g50g-#v_20g40g`!#v_20g.\" - \",,,40g.55+,v\r\n             |p02-1:g02                                        <          <       p09++g04g02g09<\r\n        @.g09<", "Most of the time is here spent in the NumberOfDivisors function. So we first cache every possible result of this function (from 0 to 10000).\r\nThe rest is simple searching for numbers where a == D(D(a)) and a != D(a).", 1, 601124986, 102399, 400, 33, 31626);
	Do(22, "Names scores", "Using names.txt (right click and \'Save Link/Target As...\'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.\r\n\r\nFor example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.\r\n\r\nWhat is the total of all the name scores in the file?", ">               v            // Calc ordered index    >   v\r\n MARY           >\"??IE\"*++:20p00p>010p0 >:00gg\"@\"-:0`#^_$0>10g74**+10pv\r\n PATRICIA                      > ^      ^          _v#         -+66:+1<\r\n LINDA                    v   _^#!p00:-1g00pg000g01$<          >v          // Bubblesort it\r\n BARBARA                  >20g30p>       040p> 040g1+g 040g2+g`|>40g:1+>60p70p66+:80p>:60g1+g\\70g1+g80g60g1+v\r\n ELIZABETH                                   |`\\-1g03 p04:+1g04<                   $<|\\p08:-1:g08p+1g07g08p <\r\n JENNIFER                        |-2p03-1:g03<       // Sum the values              ^<\r\n MARIA               v           <v+1p09+g09*g05-\"@\"<\r\n SUSAN               >090p20g50p>1>:50gg:\" \"       -|\r\n MARGARET                       |p05:-1g05       $$$<\r\n DOROTHY                   @.g09<                   \r\n ...\r\n ...", "The main thing here was sorting the list. I used [bubble sort](http://en.wikipedia.org/wiki/Bubble_sort), which is not the fastest algorithm but was pretty easy to implement in befunge.\r\nThe rest is just calculating the single scores.", 1, 4703607994, 961793, 109, 5164, 871198282);
	Do(23, "Non-abundant sums", "A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.\r\n\r\nA number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.\r\n\r\nAs 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.\r\n\r\nFind the sum of all the positive integers which cannot be written as the sum of two abundant numbers.", "v\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n                                  v       >#        v#   <\r\n>\"d\"4*:10p355***00p00g>1-::20p0\\2/>:20g\\%#^_:30p+30g>1-:#^_$v\r\n                      |:p               +1/g01g02%g01g02`g02<\r\nv                $p100<                         vp+1/g01+g05g04%g01+g05g04+2%2g+1/g01+g05g04%g01+<\r\n$                >v                   >v                  >v                   >v       v   <    g \r\n>00g40p>40g1-:40p|>40g10g%40g10g/1+g2%|>40g1+50p>50g1-:50p|>50g10g%50g10g/1+g2%|>40g50g+00g`|    0\r\n       ^                              <         ^                              <       $<   >40g5^\r\nv                <                    ^                   <\r\n>080p00g20p>20g1-20p20g10g%20g10g/1+g2/#v_v\r\n           |g02               <p08+g02g0 8<\r\n           >80g.@             ^         <", "The algorithm here is pretty ineffecient. First I brute force all the abundent numbers and then calculate every possible product of these numbers.  \r\nI used a little trick to store 2 boolean values per grid cell: The lowest bit represents if the value is abundent and the second-lowest if it can be written as two abundent numbers", 1, 10667174483, 1967688, 400, 88, 4179871);
	Do(24, "Lexicographic permutations", "A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:\r\n\r\n012   021   102   120   201   210\r\n\r\nWhat is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?", "v0123456789\r\n>\"ddd\"**1v\r\nvp129p11-<\r\n       >v>v     v     <  v    <   >  v   >\\1-\\vv    p14+1g14<\r\n>21g:1+|>|>21g0\\>:1-:#^_$>*\\:#^_$:|  >31p 141p >31g41g*11g`!|\r\n       $                          >$1^   |-\"x\" g0:\\<\\1<g14  <\r\n       @ >                              v>    >1+\\:|  1\r\n^p12-1g12p11-*-1g14g13g11.p0\\\"x\"\\-\"0\"g0:>#- #1 #$ #<  ^", "This is a really nice problem - and I kinda like the solution.\r\n\r\nIf we think about the ordered numbers we can see that the first few start with `0`, the next with `1` and so on ...  \r\nWe can also see that there are `8!` possible numbers that start with `0` (or any other digit).  \r\nSo if `1 * 8! <= (1000000 - 0)` the result starts with `0`. Otherwise if `2 * 8! <= (1000000 - 0)`, etc.  \r\nThen after we got our first digit (`2`) we can similar calculate the second with `1 * 7! <= (1000000 - 2 * 8!)`, `2 * 7! <= (1000000 - 2 * 8!)` ...  \r\nThe last thing we have to be aware of is that this method yields us to the \"n-th digit of the remaining digits\". So if we got the 6th digit for our second calculation its in fact `7`, because we already used `2`.\r\n\r\nThe program now does exactly these calculations, you can see in the top row the already used digits (they are crossed out).\r\n\r\nAll in all this program pretty fast - they could really do another version of this problem with bigger numbers.", 0, 3499, 31, 61, 8, 2783915460);
	Do(25, "1000-digit Fibonacci number", "The Fibonacci sequence is defined by the recurrence relation:\r\n\r\nFn = Fn?1 + Fn?2, where F1 = 1 and F2 = 1.\r\n\r\nHence the first 12 terms will be:\r\n\r\nF1 = 1\r\nF2 = 1\r\nF3 = 2\r\nF4 = 3\r\nF5 = 5\r\nF6 = 8\r\nF7 = 13\r\nF8 = 21\r\nF9 = 34\r\nF10 = 55\r\nF11 = 89\r\nF12 = 144\r\n\r\nThe 12th term, F12, is the first term to contain three digits.\r\n\r\nWhat is the first term in the Fibonacci sequence to contain 1000 digits?", "v\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000\r\n 00000000000000000000000000000000000000000000000001 00000000000000000000000000000000000000000000000001\r\n\r\n>5567***00p\"2\"10p 230p>v\r\n>                      >                        00g40p050p>40g1-40p40g10g%\"4\"+40g10g/1+g\"0\"-:40g10g%1+40g10g/1+g\"0\"-50g++ v\r\n v<               v<                                      |g04p+1/g01g04+1%g01g04+\"0\"p+1/g01g04+\"4\"%g01g04+\"0\"%+55p05/+55:<\r\n^<|-*+55\"d\"-g07g00<|-\"0\"g+1/g01g07+\"4\"%g01g07<p070p03+1g03<\r\n  >30g.@           >70g1+70p                 ^", "And for like the 5th time i implement an long addition algorithm. On the right side is the current number and on the left side the last number. \r\nThe only interesting thing here is probably that I calculate the next number and move the current to the left in a single cycle.", 0, 745055403, 116938, 123, 28, 4782);
	Do(26, "Reciprocal cycles", "A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:\r\n\r\n    1/2  =  0.5\r\n    1/3  =  0.(3)\r\n    1/4  =  0.25\r\n    1/5  =  0.2\r\n    1/6  =  0.1(6)\r\n    1/7  =  0.(142857)\r\n    1/8  =  0.125\r\n    1/9  =  0.(1)\r\n    1/10 =  0.1\r\n\r\nWhere 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.\r\n\r\nFind the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.", "v\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n####################################################################################################\r\n\r\n>\"d\"00p\"}\"8*60p080p090p              #v v#                  p+1/g00g04%g00g04g05<\r\n>60g>:30p>:10p>0\\00g%10g00g/v>140p050p>4 0g55+*30g%40p50g1+50p40g00g%40g00g/1+g!|\r\n  >80g.@      |p01::-1g01p+1<           vp08g03p09_v#`g09:-g+1/g00g04%g00g04g05 <\r\n^_^#p06:-1g06 ># $#          ^#         <         $<", "To calculate the repeating-digit-count we use an algorithm based on the idea of a long division. Here on the example of `1/7`\r\n\r\n| Position | Value         | Remainder     | Note                                   |\r\n|----------|-------------- |---------------|----------------------------------------|\r\n| 0        | 0,            | 10/7          | `10/7 = 1` **&** `(10%7)*10 = 30`      |\r\n| 1        | 0,1           | 30/7          | `30/7 = 1` **&** `(30%7)*10 = 20`      |\r\n| 2        | 0,13          | 20/7          | `20/7 = 1` **&** `(20%7)*10 = 60`      |\r\n| 3        | 0,132         | 60/7          | `60/7 = 1` **&** `(60%7)*10 = 40`      |\r\n| 4        | 0,1328        | 40/7          | `40/7 = 1` **&** `(40%7)*10 = 50`      |\r\n| 5        | 0,13285       | 50/7          | `50/7 = 1` **&** `(50%7)*10 = 10`      |\r\n| 6        | 0,132857      | 10/7          | **duplicate remainder -> loop closed** |\r\n\r\n**=>** RepeatingDigitCount := `6 - 0` = `6`\r\n\r\nWe use a 1000-field \"array\" to remember every remainder we already had - as soon as we reach one that is already in use the digits start repeating itself.\r\n\r\nFor better understanding here the **FindRepeatingDigitCount(int divisor)** algorithm in pseudo-code:\r\n\r\n```\r\nint current = 1;\r\nint position = 0;\r\nwhile(true) {\r\n	current = (current*10) % divisor;\r\n	position++;\r\n	\r\n	if (grid[current] != 0) return position - grid[current];\r\n	else grid[current] = position;\r\n}\r\n```", 0, 21266126, 4477, 100, 16, 983);
	Do(27, "Quadratic primes", "Euler discovered the remarkable quadratic formula:\r\n\r\n~~~\r\nn^2 + n + 41\r\n~~~\r\n\r\nIt turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39.\r\nHowever, when `n = 40`, `402 + 40 + 41 = 40(40 + 1) + 41` is divisible by 41, and certainly when `n = 41`, `41^2 + 41 + 41` is clearly divisible by 41.\r\n\r\nThe incredible formula  `n^2 - 79n + 1601` was discovered, which produces 80 primes for the consecutive values n = 0 to 79. The product of the coefficients, -79 and 1601, is -126479.\r\n\r\nConsidering quadratics of the form:\r\n\r\n~~~\r\nn^2 + an + b, where |a| < 1000 and |b| < 1000\r\n~~~\r\n\r\nwhere `|n|` is the modulus/absolute value of n\r\ne.g. `|11| = 11` and `|-4| = 4`\r\n\r\nFind the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with `n = 0`.", "v     // Project Euler - Problem 12\r\n\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>\"d\"6*:10p3\"2\"*:20p*90p230p5558***40p031pv                     >\" \":03p13pv\r\nv                                        <                    _^#`g03g09 < \r\n>\"X\"30g:10g%\\10g/3+p30g>30g+:90g\\`       #v_$>30g1+:30p:10g%\\10g/3+g\" \"- | \r\n                       ^p+3/g01\\%g01:\\\" \":<  ^                           <\r\nv                                                                         <\r\n                     v                 ># v#        p07:+1g07<         >31p50g11p60g21pv                             v                            <   @.*g12g11<\r\n>040g-1+50p260p>0:70p>:*50g70g*60g++:1`|  >:10g%\\10g/3+g\" \"-#^_70g:31g`|               >50g2+:50p40g`!#v_ >040g-1+50p>60g1+:60p:10g%\\10g/3+g\" \"-!#^_60g40g`!#v_^\r\n               ^                       ># $0                  ^#       ># $#           ^#              <#                                                    <", "If you looked at the previous problems you probably know what comes now ... (Sieve of Eratosthenes)[http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes].  \r\nTo lower the amount of A-B combinations we have to check here are 2 rules I found out:\r\n\r\n- `B` must be a (positive) prime, otherwise n=0 wouldn\'t yield a prime number\r\n- When `B` is a prime `A` must be uneven. Otherwise for n=0 the resulting number would be even and so not a prime.", 1, 37842282, 6240, 600, 162, -59231);
	Do(28, "Number spiral diagonals", "Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:\r\n\r\n    21 22 23 24 25\r\n    20  7  8  9 10\r\n    19  6  1  2 11\r\n    18  5  4  3 12\r\n    17 16 15 14 13\r\n\r\nIt can be verified that the sum of the numbers on the diagonals is 101.\r\n\r\nWhat is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?", "\"d\"55+*1+::1-01p*>:01g-:01g-:01g-:01g-:1-#v_>+\\:#<_$.@\r\nX                ^p10-2g10                <", "Let\'s look ate the diagonal numbers of our 5x5 grid:\r\n\r\n|n |info           |\r\n|--|---------------|\r\n|25|starting number|\r\n|21| = 25 - **4**  |\r\n|17| = 21 - **4**  |\r\n|13| = 17 - **4**  |\r\n|9 | = 13 - **4**  |\r\n|7 | = 9  - **2**  |\r\n|5 | = 7  - **2**  |\r\n|3 | = 5  - **2**  |\r\n|1 | = 3  - **2**  |\r\n\r\nYou can probably see the pattern here. The rest of the algorithm is simply loop from 1001^2 to 1, subtracting the right amount each round and in the end summing up all numbers.\r\n\r\nI have this little code to calculate the sum of stack values until a zero is encountered:\r\n\r\n```befunge\r\n>+\\:#<_$\r\n```\r\n\r\nPerhaps it\'s useful for someone else.", 0, 28514, 15, 54, 2, 669171001);
	Do(29, "Distinct powers", "Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:\r\n\r\n    2^2=4,  2^3=8,   2^4=16,  2^5=32\r\n    3^2=9,  3^3=27,  3^4=81,  3^5=243\r\n    4^2=16, 4^3=64,  4^4=256, 4^5=1024\r\n    5^2=25, 5^3=125, 5^4=625, 5^5=3125\r\n\r\nIf they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:\r\n\r\n    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125\r\n\r\nHow many distinct terms are in the sequence generated by ab for 2 <= a <= 100 and 2 <= b <= 100?", "v\r\n 000\r\n ###\r\n . .\r\n  .\r\n . .\r\n ###\r\n\r\n> \"]M~A~~~~~h!\"++++++*+**10p\":~+\"+*55+0p\"d\"2*1+20pv\r\nv                                                 <                                                                                                                   v                                               <     \"4\"<               @.g0+55$<\r\n       v                   <   \"4\"<                 >       $v                    v                    p05/+55p06<               v                            <                       >-!#v_             v                                  \r\n>20g\"4\">80p:0\\80gp80g1-:1-#^_$1-:#^_$\"dd\">80p:80g\\20 g>:0\\1pv>120g1p40p>050p20g60p>60g1g40g*50g+:55+%60g1p60g1-:#^_$$1-:#v_$0170p>9*70g1g+10g%70g1+:70p20g-1-#^_20g\"4\">90p30p:30g90gg:|   >55+0g1-55+0p$v>30g90g1-:1-#^_$1-:1-#^_@>80g1-:1-#v_$1-:1-#v_^\r\n                                                    ^_^#!:-1<          ^                                                 <                                                            >$30g90gp$        >                         ^\r\n                                         ^                                                                                                                                                                                                  <\"d\"     <", "This problem is really not made for Befunge. The numbers become quickly too big to be stored in a 64 bit field, and you need to remember a lot of them.\r\n\r\nMy solution is probably a bit hacky/cheaty: We calculate the numbers via long multiplication and 200 single fields. Then we calculate a hash of that number and store the hash.  \r\nThe *cheaty* part is that I needed to be sure there are no hash collisions in our set of numbers - so I tested it beforehand in a quick C# solution. And on a side note: Its disturbing how easy these problems are in a high-level language after working with Befunge for such a log time :(", 1, 6439429168, 1423681, 248, 59, 9183);
	Do(30, "Digit fifth powers", "Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:\r\n\r\n1634 = 1^4 + 6^4 + 3^4 + 4^4\r\n8208 = 8^4 + 2^4 + 0^4 + 8^4\r\n9474 = 9^4 + 4^4 + 7^4 + 4^4\r\n\r\nAs 1 = 14 is not a sum it is not included.\r\n\r\nThe sum of these numbers is 1634 + 8208 + 9474 = 19316.\r\n\r\nFind the sum of all the numbers that can be written as the sum of fifth powers of their digits.", "v                   >55+/ v v    $$_v#!:-1               <<\r\n>01>::9::*:***0\\>:#<|#\\+1\\<>9::*:***>:::55+%::*:**\\55+/v>|:\r\n                    >$ -#v_^>$>+\\:#<_vv/+55\\**:*::%+55:<->^\r\n   ^                   +1<           $>:55+%::*:**\\55+/v+\r\n                                     .v/+55\\**:*::%+55:<+\r\n                                     @>:55+%::*:**\\55+/v+\r\n                                      v/+55\\**:*::%+55:<+\r\n                                      >55+%::*:**\\55+$++^", "**Yes**. This is in fact the first program without *put* or *get* instructions. It operates completely on the stack. And that makes it **really** fast.\r\n\r\nBut *- to be fair -* the algorithm is pretty simple:\r\n\r\nFirst get the upper bound for our later search, we search for a number where `digitcount(9^5 * n) <= n`\r\n\r\nAfter our algorithm calculated that number (I resisted the urge to hard code `354294`) we test every number from 0 to limit and sum the fitting ones (there are only 6).  \r\n`4150`, `4151`, `54748`, `92727`, `93084`, `194979`", 0, 51019199, 7332, 59, 8, 443839);
	Do(31, "Coin sums", "In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:\r\n\r\n1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).\r\n\r\nIt is possible to make £2 in the following way:\r\n\r\n1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\r\n\r\nHow many different ways can £2 be made using any number of coins?", "v#########\r\n ###\r\n\r\n>00000000010p20p30p40p50p60p70p80p90p  \"d\"2*  11p921p031p 0v\r\nv                                                         $<\r\n             vp0p12:+1g120<  >g25**+70g5*+80g2*+90g+v       \r\n>21g0g1+21g0p>21g9-       |>10g5\"d\"**20g2\"d\"**+\"d\"3v>:11g\\`|\r\np                         >^ ^6+**45g05+*\"2\"g04+*g0<v<     \r\n^12-1<                              v<      v       <|-g11 <\r\n     |                           -1:<|g0:g12<p13+1g13<\r\n     >$31g.@                         >1-21p ^", "The algorithm here enumerates through every possible combination using an approach similar to counting binary:\r\n\r\n- Increment the last digit until our total sum is greater 200 (test for every combination if total sum == 200)\r\n- Then set every field from back to front to zero until you find a non-zero field\r\n- Set this field also to zero\r\n- Increment the field before ... repeat\r\n- Abort the loop when you have used every field\r\n\r\nThat is probably not the most efficient way, but I optimized this brute-force variant enough that it becomes viable.", 0, 310409597, 47970, 60, 11, 73682);
	Do(32, "Pandigital products", "We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.\r\n\r\nThe product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.\r\n\r\nFind the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.\r\n\r\n*HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.*", "v\r\n $$$$$$$$$\r\n ###############################\r\n\r\n    vp2\\0:<\r\n>\" \">  1-:|\r\n       v                                                                                                                                                 <  *\"ce\"<\r\nv   p01 1$<       vp1\\0:<         >v    >v          >$v         >v    >v          >$v         >v    >v          >$v   v\\g1:< >10g:1+10p2pv\r\n>9\"ec\"*>80p:80g55+>  1-:|  >:55+%:|>:1g!|>1\\1p55+/:!| >\\:>:55+%:|>:1g!|>1\\1p55+/:!| >*:>:55+%:|>:1g!|>1\\1p55+/:!| >55+> 1-:|>|           >80g1-:5558***-#^_$1-:1-|\r\n                        >$:^      $#    $#          <    ^      $#    $#          <    ^      $#    $#          <v++++++++$< >$          ^v                     $<\r\nv            <                    >     >                       >     >                      $>     >$        $00>9-!       ^             1\r\n             |                                                                                                                            <0               <*9*3+1*94<\r\n                        vp1\\0:<         >v    >v          >$v         >v    >v          >$v         >v    >v          >$v   v\\g1:< >10g:1+10p2pv\r\n>\"c\"49*1+3*9*>80p:80g55+>  1-:|  >:55+%:|>:1g!|>1\\1p55+/:!| >\\:>:55+%:|>:1g!|>1\\1p55+/:!| >*:>:55+%:|>:1g!|>1\\1p55+/:!| >55+> 1-:|>|           >80g1-:\"d\"-#^_$1-:55+-|\r\n                              >$:^      $#    $#          <    ^      $#    $#          <    ^      $#    $#          <v++++++++$< >$          ^                     $\r\n                                        >     >#v                     >#    >#   #<                $>     >$        $00>9-!       ^\r\nv                                               <                   v\\<           ^                                                                                  <\r\n    v                                                    -1<       v< |:g2:<\r\n             v          ># $#    >#     v#     -1<                  ^$<       \r\n>\" \">80p80g1->70p80g2g:!|>70g2g -|      > 70g:1-#^_$80g:2-#^_$0>\" \">    1-:| >+#<\\:#<_+.@\r\n                        >^       >070g2p^                                  >$^", "The main focus here was optimizing the pandigital testing. The rest is just looping over every possible number.  \r\nWe can optimize the outer loop a little bit if we look at the possible multiplicands.\r\nThere are only 2 possibilities if we need 9 digits in our calculation:\r\n\r\n- 1-digit number * 4-digit number = 4-digit number\r\n- 2-digit number * 3-digit number = 4-digit number", 0, 42123428, 7191, 166, 21, 45228);
	Do(33, "Digit canceling fractions", "The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.\r\n\r\nWe shall consider fractions like, 30/50 = 3/5, to be trivial examples.\r\n\r\nThere are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.\r\n\r\nIf the product of these four fractions is given in its lowest common terms, find the value of the denominator.", "v\r\n>110p120p\"cc\" v\r\nvp09p08       <     >80g55+/90g55+/-#v_v                           \r\n>90g80g`!#v_>80g55+/|                  >80g90g55+/*90g80g55+/*-#v_v\r\n            v       <                <                          <\r\n                    >80g55+/90g55+%-#v_v\r\n            >80g55+/|                  >80g90g55+/*90g80g55+%*-#v_v\r\n @v\\p05:<   v       <                <                          <  \r\n .>50g%:|: <        >80g55+%90g55+/-#v_v\r\n ^/\\g02$<  g>80g55+%|                  >80g90g55+%*90g80g55+/*-#v_v\r\n           0v       <                <                          <\r\n           2        >80g55+%90g55+%-#v_v\r\n           g>80g55+%|                  >80g90g55+%*90g80g55+%*-#v_v\r\n           0v       <                <                          <\r\n           1>                                v\r\n           ^ $_v#!-9p08:-1g08<_v#!-9p09:-1g09<p02*g09g02p01*g08g01<\r\n^       p0 9\"c\"<\r\n^         >#                 ^#<", "This one was relaxing. You can simple iterate through all 8100 cases and test each one in short time.  \r\nThree notable things:\r\n\r\n- You can test two fraction `a/b` and `c/d` simple of equality with the formula `a*d == b*c`.\r\n- This is my compact [GCD algorithm](http://en.wikipedia.org/wiki/Euclidean_algorithm) in befunge (stack -> stack)\r\n- This is one of the few *real* Befunge-93 programs in this series. (It doesn\'t violate the [80x25](https://github.com/catseye/Befunge-93/blob/master/doc/Befunge-93.markdown) size rule)", 0, 661502, 109, 67, 18, 100);
	Do(34, "Digit factorials", "145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.\r\n\r\nFind the sum of all numbers which are equal to the sum of the factorial of their digits.\r\n\r\nNote: as 1! = 1 and 2! = 2 are not sums they are not included.", "v\r\n>1:00p1*:10p2*:20p3*:30p4*:40p5*:v\r\nvp110$p09:*9p08:*8p07:*7p06:*6p05<\r\n      v_v#                          :-1<p11 <\r\n>90g7*>::0\\>:55+%0g\\55+/:#v_>+#<\\:#<_+-|    +\r\n    >3-.$@ |:/+55\\g0%+55: <            >:11g^\r\n    ^g11<  >                ^", "Not much to say here, we save the factorial values to increase speed and operate almost entirely on the stack (also for speed).\r\nThe rest is brute force. Our upper limit is `9!*7 = 2540160`, because `9!*8` has only 7 digits and so is impossible to be a curious number.", 0, 493980359, 80933, 45, 7, 40730);
	Do(35, "Circular primes", "The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.\r\n\r\nThere are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.\r\n\r\nHow many circular primes are there below one million?", "v          // Project Euler - Problem 35\r\n\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n\r\n>\"d\"45**:10p5\"d\"*:20p*00p230p\" \":03p13pv    v0             p090<\r\nv                                      <                      _^#`g03g00<\r\n>\"X\"30g:10g%\\10g/3+p30g>30g+:00g\\`       #v_$>30g1+:30p:10g%\\10g/3+g\" \"-|\r\n   >90g\"= \",,.@        ^p+3/g01\\%g01:\\\" \":<  ^                          <\r\nv                                           <\r\n   ^_v#      !-g00p03:+1g03$<0                                                                                      <\r\n                                              v                                 <                            >     v\r\n>230p>30g::10g%\\10g/3+g\"X\"-#^_:150p1\\55+/:!#v_>:2%!#v_:5%!#v_55+/\\55+*\\50g1+50p:|>$60p:70p>::10g%\\10g/3+g\" \"-|     :\r\n                                            >                                   >^        |p05:-1g05+*g06%+55 \\/+55<\r\n                                                                                          >55+70g.,90g1+90p0> $>$   ^\r\n                                                    >      >                                               $^> ^", "Thats one big [sieve](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes), even though not as big as the on in problem 10.\r\nHere we needed a way to \"rotate\" a number: `value = value%10 * 10^digitcount + value/10`. The rest is standard befunge stuff and trying to optimize it.", 1, 176748467, 27565, 2000, 516, 55);
	Do(36, "Double-base palindromes", "The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.\r\n\r\nFind the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.\r\n\r\n(Please note that the palindromic number, in either base, may not include leading zeros.)", "v      \r\n0             v                      \\<     v            *2\\<     >:.55+,\\   v\r\n>093194*+**>::>55+*10p:55+%10g+\\55+/:#^_$::0>10p:2%10g+\\2/:#^_$-!#^_$        v\r\n           |:-1                                                              <\r\nv          <     v                      \\<     v            *2\\<     >:.55+,\\v\r\n>93194*+**>::55+/>55+*10p:55+%10g+\\55+/:#^_$::0>10p:2%10g+\\2/:#^_$-!#^_$     v\r\n          |:-1                                                               <\r\n          >\"= \",,>+\\:#<_+.@", "The *trick* here is that we only need to test 1998 numbers. Because there are only so much base10 palindromes:\r\n\r\n- The numbers from `1` to `999` mirrored result into to palindromes `11` to `999999`\r\n- The numbers from `1` to `999` mirrored at the last digit result into to palindromes `1` to `99999`\r\n\r\nThen we only need to test these numbers whether they are also binary palindromes. ", 0, 969574, 172, 78, 8, 872187);
	Do(37, "Truncatable primes", "The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.\r\n\r\nFind the sum of the only eleven primes that are both truncatable from left to right and right to left.\r\n\r\n*NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.*", "v\r\n\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>\"d\"45**:10p5\"d\"*:20p*00p230p\" \":03p13pv    v075320        p090<\r\nv                                      <                      _^#`g03g00<\r\n>\"X\"30g:10g%\\10g/3+p30g>30g+:00g\\`       #v_$>30g1+:30p:10g%\\10g/3+g\" \"-|\r\n   >90g\"= \",,.@        ^p+3/g01\\%g01:\\\" \":<  ^                          <\r\nv                                           <                                                                                                      <\r\n          v            >#                       ># $#                                                                                      v# -1<\r\n                       $   >v                                         >$\\          v                                    < >::.55+,90g+90pv\r\n>:!#v_70p9> :70g55+*+:00g\\`|>::10g%\\10g/3+g\"X\"-#^_::55+\\`#v_:55+/1\\:!#^_55+/\\55+*\\v>::10g%\\10g/3+g\"X\"-#v_\\:50p%50g55+/\\:|>|              >\\>:1-#^_$^\r\n    >$\"= \",,90g.@      ^   <                              >$          #^!:       #<                    >$$0         >    ^>              ^\r\n                                                                                                                    ^1$$<", "The approach for this problem is to first iterate through the left-truncatable primes and test if these are right-truncatable. All with the help of our trusty companion the *sieve of Eratosthenes*.  \r\nTricky was that the generation of left-truncatable primes, my original algorithm was recursive and I had to transform it to an iterative one for befunge.", 1, 128154558, 20717, 2000, 514, 748317);
	Do(38, "Pandigital multiples", "Take the number 192 and multiply it by each of 1, 2, and 3:\r\n\r\n    192 × 1 = 192\r\n    192 × 2 = 384\r\n    192 × 3 = 576\r\n\r\nBy concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)\r\n\r\nThe same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).\r\n\r\nWhat is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?", "v#########\r\nv#########    v                                                                                                                                              <#     p145<\r\n #########         v          +1<           v            <  v               <                 vp2\\0:<         >v    >v          >$v   v\\g2:<\r\n>\"ec\"*31p>241p>01-1>:31g*\\:41g-#^_$>\\10p01-\\>:55+%\\55+/:#^_$>10g55+*+10p:1+#^_$10g\\:1+#v_$:55+>  1-:|  >:55+%:|>:2g!|>1\\2p55+/:!| >55+> 1-:|>#v_$41g1-:41p1-#^_31g1-:31p|\r\n                                   ^                                                  \\<           $>$:^      $#    $#          <v++++++++$<\r\n                                                                                                            $$>     >          $0>9-!\\$     ^ >.     @     ,,,,, \"RORRE\"<\r\n  v            <\r\n02>:31g*\\:41g-#^_31g*", "Not much to say here. I needed to implement a way of merging numbers and a way of testing for pandigitals (we already did that in problem 32).\r\nThen we start from `9999` downward, because bigger numbers will always lead to 10 digits or more.", 0, 3567967, 624, 169, 6, 932718654);
	Do(39, "Integer right triangles", "If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.\r\n\r\n{20,48,52}, {24,45,51}, {30,40,50}\r\n\r\nFor which value of p ? 1000, is the number of solutions maximised?", "v\r\n>010p020p630p\"d\"55+*90p050p30g3/70p         v\r\n vp07/3g03p050                                                    p03+2<\r\nv                     >#        v# p07-1<           >10p30g20pv\r\n>30g::270g*-*\\70g-2*%#^_50g1+50p>70g:2-#^_$50g:10g`#^_$       >30g:90g-|\r\n >                             $^$          <                    @.g02$<", "We have the two formulas `a^2 + b^2 = c^2` and `a + b + c = p`. We can insert the second in the first and get `b = p*(p-2a) / 2*(p-a)` and `c = p-(b+a)`.  \r\nThe we just go through all possible values for a and p and test if b is an integer. Then we search for the value of p with the most possible values of a.", 0, 3815878, 827, 72, 6, 840);
	Do(40, "Champernowne\'s constant", "An irrational decimal fraction is created by concatenating the positive integers:\r\n\r\n0.123456789101112131415161718192021...\r\n\r\nIt can be seen that the 12th digit of the fractional part is 1.\r\n\r\nIf d(n) represents the nth digit of the fractional part, find the value of the following expression.\r\n\r\nd(1) × d(10) × d(100) × d(1000) × d(10000) × d(100000) × d(1000000)", "v\r\n>01:55+*:55+*:55+*:55+*:55+*:55+*130p v\r\n         v                                           <\r\n>110p120p>:10g920g**`!#v_10g920g**-10g1+10p20g55+*20p^>v          <\r\n  >30g.@               >1-:10g/20g+\\      10g%10g\\-1-:|>\\55+/\\1-:#^_v\r\n  $                                   $               >           :^\r\n^_^#:                                 <#                p03*g03%+55$<", "This one is really great - I came up with an O(log n) algorithm (crazy fast) for determining the n-th digit.  \r\nFirst I tested it in LinqPad, so here the C# code for the algorithm:\r\n\r\n```csharp\r\npublic int digitAt(int pos) {\r\n    int digitcount = 1;\r\n    int digitvalue = 1;\r\n    \r\n    // Get DigitCount of current number\r\n    while(pos > digitvalue * 9 * digitcount) {\r\n        pos -= digitvalue * 9 * digitcount;\r\n        digitcount++;\r\n        digitvalue *= 10;\r\n    }\r\n    \r\n    // current number and digit-position in number\r\n    int value = digitvalue + (pos - 1)/digitcount;\r\n    int digit = digitcount - (pos - 1)%digitcount - 1;\r\n    \r\n    return getInternalDigit(value, digit);\r\n}\r\n\r\npublic int getInternalDigit(int value, int digit) {\r\n    return (value / (int)Math.Pow(10, digit)) % 10;\r\n}\r\n```", 0, 1486, 16, 69, 7, 210);
	Do(41, "Pandigital prime", "We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.\r\n\r\nWhat is the largest n-digit pandigital prime that exists?\r\n", "vXXXXXX\r\nvXXXXXX\r\n$\r\n>7  12p 0>:0\\1p::\"1\"+v     \r\n         |-g21:+1p0\\ <\r\nv   p231$<\r\n              >32g1gv\r\n        >32g2%| vp24<>2g1g1+32gv \r\n>32g:1g`|     >0    ^^3p0g23p0<1\r\n^       >032g1pv>42g0g32g0g42g^p\r\n^p23+1g23      <          vp230<\r\n     v6:-1g26*+ 55<0p26g21<          @.<\r\n     >2p0g\"0\"-+62g|                    $\r\n               #  >:>302pv >:02g2-:*` !|\r\n               $    >!\\2% +|%p20+1:g20:<\r\n                    ^`2::< $  \r\n               ^           <", "Perhaps you remember from elementary school that numbers with a digit sum divisible by three is also divisible by three (an so not a prime).  \r\nSo our number can\'t be 9 digits long (digit sum = `45`) nor 8 (digit sum = `36`). Our next best try is a 7-digit palindrome.\r\n\r\nWith the [QuickPerm algorithm](http://www.quickperm.org/) we generate all the permutations and test them for their primality.\r\nThis time we don\'t use a prime sieve, the numbers are just too big and it\'s faster with a simple naive prime test.\r\n\r\nThe rest is just implementation.\r\nBut the resulting code looks imho pretty nice because it really uses the four directions of befunge and often intersects with itself, even though I think that doesn\'t make it more readable.", 0, 83726, 31, 40, 17, 7652413);
	Do(42, "Coded triangle numbers", "The nth term of the sequence of triangle numbers is given by `t(n) = 0.5 * n(n+1)`; so the first ten triangle numbers are:\r\n\r\n`1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...`\r\n\r\nBy converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is `19 + 11 + 25 = 55 = t(10)`. If the word value is a triangle number then we shall call the word a triangle word.\r\n\r\nUsing words.txt (right click and \'Save Link/Target As...\'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?\r\n", "                              v ################################################################################\r\n                                ################################################################################\r\nA                               ################################################################################\r\nABILITY                         ################################################################################\r\nABLE                            ################################################################################\r\nABOUT                          v                                       <\r\nABOVE                         > 1\"/&\"*+00p>\"P\":10p 5:20p *30p 050p 260p^\r\nABSENCE                        \r\nABSOLUTELY                     >50g1+:50p :1+*2/  \"0\"\\ :10g%\" \"+\\10g/p v\r\nACADEMIC                       |`\\g03                      /2*+1: +1g05<\r\nACCEPT                          \r\nACCESS                         >070p0>70g60gg:\" \"-!#v_\"@\"-+v\r\nACCIDENT                             ^p07+1g07      $#     <\r\nACCOMPANY                      |-g00p06+1:g06pg06*39<\r\nACCORDING                      \r\nACCOUNT                        >260p 0 >93*60gg:10g%\" \"+\\10g/g\"0\"-!v\r\nACHIEVE                                |-g00 p06+1:g06            +<\r\nACHIEVEMENT                          @.<\r\n...\r\n...", "Similar to problem 22 this is not quite befunge-friendly due to enormous input size. \r\nBut otherwise it wasn\'t hard, I create for every word the word value and count the triangle numbers in it.\r\n\r\nTwo little tricks:\r\n\r\n - I cached the triangle numbers from 1 to 400 (biggest possible word value is 364 because the longest word is 14 letters)\r\n - to count the triangle numbers just add the boolean results of the `isTriangle` function. Because true is `1` and false is `0` this results equals the number of triangle numbers.\r\n", 1, 526637, 406, 112, 1788, 162);
	Do(43, "Sub-string divisibility", "The number, `1406357289`, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.\r\n\r\nLet d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:\r\n\r\n - d2d3d4 =406 is divisible by 2\r\n - d3d4d5 =063 is divisible by 3\r\n - d4d5d6 =635 is divisible by 5\r\n - d5d6d7 =357 is divisible by 7\r\n - d6d7d8 =572 is divisible by 11\r\n - d7d8d9 =728 is divisible by 13\r\n - d8d9d10=289 is divisible by 17\r\n\r\nFind the sum of all 0 to 9 pandigital numbers with this property.", "vXXXXXXXXX\r\nvXXXXXXXXX\r\n\r\n>902p012p9>:0\\1pv\r\n          |\\-1: <\r\n>12g55+, #$ \" =\",, . @                                       vp20<\r\n|`9g20    <                                                  <  <\r\n             >$0v        > v                         >002g0g\"0\"-1p v\r\n>02g0g\"0\"-:9`|  >:22p55+-| >22g1g     #v_ 02g0g\"9\"`!#^_         ## v\r\n             >1+^        >0|-9p22+1:g22<vp20-1g20p0g20+\"0\"g22p1g221<\r\nv!`g200                                 <             p20+1g20< ##\r\n                           >  02g0g\"9\"`!#v_                   ^  +\r\n                                         >002g0g\"0\"-1p\"X\"02g0p^  1\r\n>#v_002p                   032p0>:0g\"0\"-32g55v>12p>             ^g\r\n  >02g9-!02g8-!02g7-!++v        |-9\\+1:p23+*+<+                  2\r\n  v                    <        >$32g:.55+,12g^                  0\r\n  >02g6-70g\"0\"-55+*80g\"0\"-+55+*90g\"0\"-+89+%+!v>++#^_02g0g\"9\"`!#v_^\r\n  v!+%+58+-\"0\"g08*+55+-\"0\"g07*+55-\"0\"g06-5g20<+v\"X\"p1-\"0\"g0g200<#\r\n  >02g4-50g\"0\"-55+*60g\"0\"-+55+*70g\"0\"-+47+%+!v+>02g0p02g1+02p   ^\r\n  v!+%+70+-\"0\"g06*+55+-\"0\"g05*+55-\"0\"g04-3g20<+\r\n  >02g2-30g\"0\"-55+*40g\"0\"-+55+*50g\"0\"-+05+%+!v+\r\n  v!+%+30+-\"0\"g04*+55+-\"0\"g03*+55-\"0\"g02-1g20<+\r\n  >02g0-10g\"0\"-55+*20g\"0\"-+55+*30g\"0\"-+02+%+!>^", "While trying to optimize this problem I found that you don\'t even need a program to solve this.\r\nYou can easily get the result by calculating it on paper.\r\nI have documented my calculations in my [Github repo](https://github.com/Mikescher/Project-Euler_Befunge).\r\nBut I wanted an program to do this (where you could for example change the constraints), so I wrote this.\r\n\r\nThe code here was a tight fit into the Befunge-93 80x25 grid, not because of some big data structures but because of a lot of code.\r\n\r\nHere we generate all combinations from the last digit to the first, we significantly limit the amount of possible combinations by checking the constraints for every number.  \r\nFor example we are at `???????410`, we then don\'t need to evaluate the first 7 digits because constraint 7 is violated (divisibility of d_789 by 17).\r\nThis way instead of evaluating `3,628,800` possibilities we only have to look at `1702`.", 0, 821317, 140, 68, 23, 16695334890);
	Do(44, "Pentagon numbers", "Pentagonal numbers are generated by the formula, `Pn=n(3n-1)/2`. The first ten pentagonal numbers are:\r\n\r\n> 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...\r\n\r\nIt can be seen that `P4 + P7 = 22 + 70 = 92 = P8`. However, their difference, `70 - 22 = 48`, is not pentagonal.\r\n\r\nFind the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and `D = | Pk - Pj |` is minimised; what is the value of D?\r\n", ">v%%% %%%%       >    v\r\nv06p09:/2*-1*3:p06::+1<vg07g09                         <<  <\r\ng$ >:70p:3*1   v #      >0v>vv p03+g03*2:p04-\\g04+g03:<\r\nv                      <3 pp2# v/4    <   >:30g+40g`! |\r\n1#  >            4**1+:0^ 40>0g>:40g`#^_>:|:/4p03/2g03< $\r\n>-:|^6-p08:/2*-< #        >^ >30g2/30p4/^ >$30g:*-30g\\  |\r\n 8 >$$           ^v030:+1**46+g09g08             ># !#  # _^\r\n >::**::**8*20p1 ^v>vv p03+g03*2:p04-\\g04+g03:<@.-g08g0 9<\r\n                  pp2# v/4    <   >:30g+40g`! |  ^5%6   <$\r\n                  40>0g>:40g`#^_>:|:/4p03/2g03< >$     ^ \r\n                  >^ >30g2/30p4/^ >$30g:*-30g\\ #^_6%5-#^_^", "My first attempt at this problem took over 5 hours to compute and had a complexity of O(n^3). \r\n\r\nThe problem is that you need a square root to inverse the pentagonal formula and Befunge has no square root function.\r\nSo I needed to implement my own version of integer square roots in Befunge (see [wikipedia](http://en.wikipedia.org/wiki/Methods_of_computing_square_roots)).\r\nThe program is still not really fast but it\'s good that I managed to speed it up to a time where you can execute it without waiting the whole night.\r\n\r\nAlso this program is nicely compact, by the time I\'m writing this my Befunge interpreter [BefunExec](http://www.mikescher.de/programs/view/BefunGen) has gotten a display of all possible paths a program can take.\r\nAnd if you look at the graph of this program, it looks pretty interesting...", 0, 1509045439, 258993, 60, 11, 5482660);
	Do(45, "Triangular, pentagonal, and hexagonal", "Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:\r\n\r\n Name       | Formula              | Numbers\r\n------------|----------------------|-------------------------\r\nTriangle    | `T_{n} = n(n+1)/2`   | `1, 3, 6, 10, 15, ...`\r\nPentagonal  | `P_{n} = n(3n-1)/2`  | `1, 5, 12, 22, 35, ...`\r\nHexagonal   | `H_{n} = n(2n-1)`    | `1, 6, 15, 28, 45, ...`\r\n\r\nIt can be verified that `T285 = P165 = H143 = 40755`.\r\n\r\nFind the next triangle number that is also pentagonal and hexagonal.", "v                 >v\r\n>8::**::**8*:*20pv0v>vv p03+g03*2:p01-\\g01+g03:<\r\nv           +\"l#\"<3pp2# v/4    <   >:30g+10g`! |\r\n>1+::2*1-*64**v   010>0g>:10g`#^_>:|:/4p03/2g03<\r\n^        <  $<>1+:^>^ >30g2/30p4/^ >$30g:*-v\r\n@.*-1*2:_^#!_^#!                    -5%6g03<", "This problem is very similar to the previous one. We iterate through all Pentagonal numbers (starting at P_144) and test the numbers if they are hexagonal.\r\n\r\nThe test for hexagonal numbers is the same as in Problem-44, but we have to expand the iSquare function for int64 numbers ([20] is now 2^60 instead of 2^30).\r\n\r\nThe major trick is that we only need to test for the hexagonal property. Because all hexagonal numbers are also Triangle numbers. \r\nThink about it, a Hexagon has six edges and a Triangle three, so every Hexagonal contains two triangles.\r\n\r\n`H_{n} == T_{2*n}`", 0, 25312679, 3494, 48, 6, 1533776805);
	Do(46, "Goldbach\'s other conjecture", "It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.\r\n\r\n`9  = 7  + 2 * 1^2`  \r\n`15 = 7  + 2 * 2^2`  \r\n`21 = 3  + 2 * 3^2`  \r\n`25 = 7  + 2 * 3^2`  \r\n`27 = 19 + 2 * 2^2`  \r\n`33 = 31 + 2 * 1^2`\r\n\r\nIt turns out that the conjecture was false.\r\n\r\nWhat is the smallest odd composite that cannot be written as the sum of a prime and twice a square?", "v\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n                                                                                                                            >2                               v           >0v>vv p09+g09*2:p07-\\g07+g09:<\r\n                                                                                             v           p+1/g01\\%g01:\\\"O\"< $v                               <           9@pp8# v/4    <   >:90g+70g`! |\r\n>\"d\"2*:10p\"2\":20p*40p230pv                                     >030p 350p                    >50g2+:50p::10g%\\10g/1+g\" \"-#^_^>1+:50g-!#v_::10g%\\10g/1+g\" \"-!#^_:50g\\-2/:0^.70>0g>:70g`#^_>:|:/4p09/2g09<\r\nvp08*8**::**::8p11p10:\" \"<                                    _^#`g03g04<                    ^                                         >                                  ^>^ >90g2/90p4/^ >$90g:*-#v_v\r\n>\"X\"30g:10g%\\10g/1+p30g>30g+:40g\\`       #v_$>30g1+:30p:10g%\\10g/1+g\" \"-|                    $                               ^                                                                      <\r\n                       ^p+1/g01\\%g01:\\\" \":<  ^                          <                    ^                                                                                                        <", "I really missed my [sieve of erastothenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). There were really a few problems without primes in a row.\r\n\r\nIn this problem we go through all primes `i`, search through all smaller primes `j` were `(i-j)/2` is a quadratic number. If you can\'t find one, this falsifies the theorem.\r\n\r\nAlso we use the code from problem 46 to calculate the integer square root.", 1, 77542913, 13899, 200, 57, 5777);
	Do(47, "Distinct primes factors", "\r\n\r\nThe first two consecutive numbers to have two distinct prime factors are:\r\n~~~\r\n14 = 2 × 7\r\n15 = 3 × 5\r\n~~~\r\nThe first three consecutive numbers to have three distinct prime factors are:\r\n~~~\r\n644 = 2 × 2 × 7 × 23\r\n645 = 3 × 5 × 43\r\n646 = 2 × 17 × 19.\r\n~~~\r\nFind the first four consecutive integers to have four distinct prime factors. What is the first of these numbers?\r\n", "v\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n\r\n>\"d\"4  *:10p5\"d\"*:20p*00p230p\" \":03p13pv                       >040p030p>>30g1+:30p:10g%\\10g/3+g\"X\"-#v_30g40g:1+40p:10g%\\10g/3+p00g30g`#v_v\r\nv                                      <                      _^#`g03g00<^                           <                                  < 0\r\n>\"X\"30g:10g%\\10g/3+p30g>30g+:00g\\`       #v_$>30g1+:30p:10g%\\10g/3+g\" \"-|v                                              p+3/g01\\%g01:-1g04<\r\n                       ^p+3/g01\\%g01:\\\" \":<  ^                          <>1>:0:40p50p>:40g:10g%\\10g/3+g%       #v_40g:10g%\\10gv\r\n                                                                           +         |!`\\g+3/g01\\%g01:p04:+1g04:<p05+1g05/g+3/<\r\n                                                                           4         >$50g4-#v_080p:::4+60p70p3->:70g-  #v_80g1+:80p4-#v_3-.$@\r\n                                                                           ^                 <                  |-g06:+1<              <\r\n                                                                                             ^                 $<        >:0:40p50p>:40g:10g%\\10g/3+g%       #v_40g:10g%\\10gv\r\n                                                                                                                        ^         <|!`\\g+3/g01\\%g01:p04:+1g04:<p05+1g05/g+3/<\r\n                                                                                                                                   >$50g4-#v_80g1+80p v\r\n                                                                                                                                  |   -4g08           <\r\n                                                                                                                                  >3-.$@   >080p:70g\\`|\r\n                                                                                                                ^                                     <", "This is a relative straightforward problem:\r\n\r\n - First we calculate all primes from `0` to `200 000` with a sieve of Eratosthenes.\r\n - Then we collect all primes side by side together in the top rows, because we only need to iterate through the primes and never actually do a prime test.\r\n - If we iterate through all the primes and test the divisibility we can calculate the number of *distinct prime*\r\n - So we check every fourth number (if it has 4 distinct prime factors).\r\n - If we found one, we test the 7 surrounding numbers for 4 adjacent matches (the first one we print out and exit the program)\r\n\r\nThis program is not that fast, even I did multiple performance improvements:\r\n\r\n - We pre-calculate the primes with an sieve of Eratosthenes\r\n - We generate an easily iterable array of primes\r\n - We test only every 4th number - this reduces the number of distinct prime factor calculations greatly\r\n - We early exit the \"test 7 surrounding numbers\" method, when we reached a point where there can\'t be a positive result\r\n\r\nBut still, it\'s mostly optimised brute force and not pretty fast.", 1, 3227917351, 537798, 400, 518, 134043);
	Do(48, "Self powers", "The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.\r\n\r\nFind the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.", "v   v0p01**<  >:30p::>20p\\1-:  #v_$$v\r\n5>8#<\"}\"* #*>:|      ^%g01*g02:\\<   2\r\n>5+:::*:*: ^^-># $# .# @#1g03%g01+g0<", "I like the occasionally really easy problems between the others. It\'s like a little break sometimes.\r\n\r\nThe \"trick\" here is to understand the modulo operator. If you have `(a + b) % c` you can also write `a%c + b%c`.\r\nAnd also you can write `(a * b)%c` as `(a%c) * (b%c)`.\r\n\r\nSo all we do is calculate the sum kinda normally, but we do modulo `10^10` after each step (every addition and multiplication).\r\nWe guarantee this way that out numbers never exceed the range of an 64bit integer.", 0, 11530541, 3728, 37, 3, 9110846700);
	Do(49, "Prime permutations", "\r\n\r\nThe arithmetic sequence, `1487, 4817, 8147`, in which each of the terms increases by `3330`, is unusual in two ways: \r\n - (i) each of the three terms are prime, and, \r\n - (ii) each of the 4-digit numbers are permutations of one another.\r\n\r\nThere are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.\r\n\r\nWhat 12-digit number do you form by concatenating the three terms in this sequence?\r\n", "v?>:55+%2+\\55+/:5v>\"Z%\"v>+\\55+/:55v>v v           0`*\"ce\":+*\"Z%\"$<\r\n\" :v55:/+55\\+2%+5<\\  v<*2v+55\\+2%+<:v>$:.48*,\"Z%\"*+:.48*,\"Z%\"*+. @\r\n( :>+%2+\\55+/2+***^  01+%/>* -#v_-!|:|<                          #\r\n%   v5:/+55\\+2%+55::g<:1+2*    v   <\">::2%!#v_v >10g\\%!#v_:10g2/`|\r\n\"   >5+%2+\\55+/:55v   p05+*    $   ve#< v%3:>#<#^ #<    >    v   :\r\n* +v***+2/+55\\+2%+<   ^<5>^    $    c`  > !#^_10p7:^:+6_^#%\\g01-2<\r\n7 1>\\\"Z%\"*+:55+%2+\\55+/:^      v   <\"*^                   $$$<\r\n>+^                            <    >^", "This could be the first problem with prime numbers but without a prime sieve.  \r\nWe iterate through the numbers from `1488` to `3340` and search for palindromes. \r\nTo speed up the palindrome calculation we calculate the product of each digit plus two and compare the product of our three numbers.\r\nThis is only an approximation, but a rather good one. In tested the numbers from `0` to `100 000` and there were **zero** failures.\r\n\r\nSo now we\'ve got the numbers where `digit_product(p) == digit_product(p+3330) == digit_product(p+6660)` (in fact there are only 40 of these).\r\nWe then use a simple primality test to check if all three numbers are prime.  \r\nThe primality test is basically a port of the [wikipedia](http://en.wikipedia.org/wiki/Primality_test) version to befunge. Wit it we only have to do `n/6` divisions to test a number `n` for primality.\r\n\r\nAll in all tis leads to a fast, small and not very grid-intensive program (Only one field is used, *and only as a temporary storage to swap three values*).", 0, 378809, 124, 66, 8, 296962999629);
	Do(50, "Consecutive prime sum", "The prime 41, can be written as the sum of six consecutive primes:\r\n\r\n> 41 = 2 + 3 + 5 + 7 + 11 + 13\r\n\r\nThis is the longest sum of consecutive primes that adds to a prime below one-hundred.\r\n\r\nThe longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.\r\n\r\nWhich prime, below one-million, can be written as the sum of the most consecutive primes?", "v          // Project Euler - Problem 50\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>\"d\"45**:10p5\"d\"*:20p*00p230p\" \":03p13pv                       >040p030p>>30g1+:30p:10g%\\10g/1+g\"X\"-#v_30g40g:1+40p:10g%\\10g/1+p00g30g`#v_v\r\nv                                      <                      _^#`g03g00<^                           <                                  < 0\r\n>\"X\"30g:10g%\\10g/1+p30g>30g+:00g\\`       #v_$>30g1+:30p:10g%\\10g/1+g\" \"-|v                    p091 p080 p07-10 p060 p+1/g01\\%g01:p04:-1g04<\r\n   >90g\"= \",,.@        ^p+1/g01\\%g01:\\\" \":<  ^                          <v                              p08<\r\n                                                                         >70g1+:70p:10g%\\10g/1+g80g+:00g\\`#^_70g1-70p$v\r\nvp05g04g08                                                                           <                               <<\r\n>:50g\\50g:10g%\\10g/1+g-#v_$. @              >80g60g1-:10g%\\10g/1+g+70g:10g%\\10g/1+g-v^p09*-10g09<p07-1g07p08-g+1/g01\\ %g01:g07g08<\r\n^              p05-1g05<_>$060g90g+`#v_90g1-|                                       >:00g\\`!#v_8 0p90g:60g+60p70g+70p^>90g1-     |\r\n                                            >80g60g:10g%\\10g/1+g-70g1+:10g%\\10g/1+g+^        $  ^p06+1g06p08-g+1/g01\\% g01:g06g08<\r\n                                     >                                                       >                        ^", "My first approach here was a simple brute force algorithm, but that one was *far* too slow. So I needed an more intelligent algorithm. And I have to say the one I came up is pretty quick and I like the concept that lies behind it.\r\n\r\nFirst I calculated the primes from `0` to `1 000 000`.\r\n\r\nNext I calculated the maximum chain *(starting by the first prime `2`)* with a sum less than one million.\r\n\r\nNow think of all the primes laid down in an array side by side:\r\n\r\n**1)** We move our chain from left to right until the sum exceeds one million (the movement is a really cheap operation: take the previous sum, subtract the most left prime and add the new prime from the reight side).\r\n\r\n**2)** Then we shorten the chain length by one as we remove the most left prime.\r\n\r\n**3)** After that we do the movement back wards (from right to left) until we end up at the left end of our prime array.\r\n\r\n**4)** Then we again shorten the chain *(this time by removing the right tail)* and start over again (by moving right).\r\n\r\n**X)** In every step we test if the current sum is a prime number and if so we print it and terminate the program.\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nOOOOOOOOOOOOO  // the prime array\r\n#####OOOOOOOO  // our chain\r\nO#####OOOOOOO  // move right\r\nOO#####OOOOOO\r\nOOO#####OOOOO  // until sum > MAX_VALUE\r\nOOOO####OOOOO  // shorten left\r\nOOO####OOOOOO  // move left \r\nOO####OOOOOOO \r\nO####OOOOOOOO \r\n####OOOOOOOOO  // until left side is hit\r\n###OOOOOOOOOO  // shorten right\r\nO###OOOOOOOOO  // repeat until prime is found\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nThis algorithm works because we first test every possibility with maximum chain length, and then every with length = `maximum - 1` and so on and so on. So the first prime that we find is from the longest possible chain.\r\n\r\nThere are two nice things about this algorithm:\r\n\r\n - We don\'t need to calculate an extreme amount of prime sums. The step from the sum of one chain to the next is literally only an addition and an subtraction\r\n - Because we start with the longest chain and reduce its length in every step, the first prime we find is directly our optimal result.", 1, 180368553, 30904, 2000, 512, 997651);
	Do(51, "Prime digit replacements", "By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values:`13`, `23`, `43`, `53`, `73`, and `83`, are all prime.\r\n\r\nBy replacing the 3rd and 4th digits of `56**3` with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: `56003`, `56113`, `56333`, `56443`, `56663`, `56773`, and `56993`. Consequently `56003`, being the first member of this family, is the smallest prime with this property.\r\n\r\nFind the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.", "\"c\"02p                v >02g1+::02p 2%!#v_5%!#v_312p>12g1+:12p27*-!#v_022pv> v\r\n##############        >#|v#-*8\"}\"g20<   $           ^                < >1#0|\r\nOOO OO OOO   #        ^ @# >#       ^#  <     <                     <^_^#<1>v\r\n##############                                              >22g1+:22p3-!^2#\r\n110001#??????#         >                                    ^               <\r\n101001#??????#           > ^v24 pg21+7\\+\"0\"%+55g24:>#<:      !#v_ v       g+\r\n100101#??????#              >g55+/42p>             ^ |-\"0\"gg21: -1<p24g206   <\r\n100011#??????#                       ^pg21+7\\+\"0\"g22:<      #>#$>1-:7+12gvgg\r\n011001#??????#   >82g8-|    @                                ^6<|:\\-\"0\"g <\"2\r\n010101#??????#   $     >72g.^            >$                 ^>$#<55+*+55+v02\r\n010011#??????# vp29g22p281  $_v# `/2g25:_^#%\\g25< v_v# %2:  <v*+55+*+55+*<\"-\r\n001101#??????#   $            :         >^   ># ^#>#<:3%v    >+55+*+v     >^\r\n001011#??????#   $            >2-52g\\%!#^_6+:^:7p25_^#  <   ^   p27:<\r\n000111#??????# >92g1+92pv       v_v#        :>#<:42g55+%\"0\"+\\7+92g4+p42 v\r\n############## |-9g29<  >602g42p>1 -:12gg\"0\"-| ^               <p24/+55g<\r\n               > ^   ^    $<   v6$<          >:92g\"0\"+\\7+92g4+p^\r\nv_v# `/2g25:_v# %\\g25< v_v# %2<>>1-:7+92g4v>v\r\n8            v    ># ^#>#<:3%v: |:\\-\"0\"g+ <+5\r\n2 >:2-52g\\%!#v_6+:^:7p25_^#  <+ >$55+*+55+*^5\r\n>g1+82p      >$            ^  ^ *+55+*+55+*+<", "This is effectively an optimized implementation of [this algorithm](http://www.mathblog.dk/project-euler-51-eight-prime-family/).  \r\nYou can see the ten patterns on the left side and beside them the area were we build our numbers.\r\n\r\nSo what we do is iterate through the numbers from `100` to `1 000`, through the ten patterns and through the digits `0`, `1` and `2`.\r\nIn each iteration we generate the number (from value, pattern and digit) and test for it primeness (with a simple [primality test](http://en.wikipedia.org/wiki/Primality_test) - no prime sieve).\r\nIf we found a prime we count the number of primes in it\'s family and if this count is eight we print the generated number and exit.\r\n\r\nThis program is not the fastest, because I check all the primes \"manually\" and not with an prime sieve each iteration takes quite a time.\r\nBut I wanted this to fit into the befunge-93 size restrictions, and even without a sieve the execution time is OK - for a befunge program.", 0, 802550671, 113896, 78, 20, 121313);
	Do(52, "Permuted multiples", "It can be seen that the number, `125874`, and its double, `251748`, contain exactly the same digits, but in a different order.\r\n\r\nFind the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.\r\n", "55+>v>v>5+/>::103p55+*>55+/        :#v_$212pv\r\nXX  :6/5 >  ::103p55+*^p30*g30+2%+55:<      :\r\nXX  0:1:  v$_v#!:       /+55<*+55p311* <g21 <\r\nXX  1p1p  1  >:55+%2+13g*13p^     >:12g^\r\n  >^>^>^  >3g03g-   #v_12g1+:12p7-|\r\n  ^*+55$_^#!`\\g11:+1$<        @$$.<", "To be a permutation all six numbers have to have the same digit count. So `digitcount(x) == digitcount(x*6)`.\r\n\r\nThis for each number of digits only given for the numbers from `10^n` to `10/6 * 10^n`.  \r\nWe perform the permutation check with an modified version of the algorithm used in problem-49 *(product of all digits plus two)*.\r\nBut we generalise the code to work with every number of digits.\r\n\r\nAnd because we greatly limited the amount of numbers to search and the permutation test is pretty fast this is all we need to do (except run the code).", 0, 18887060, 2917, 45, 6, 142857);
	Do(53, "Combinatoric selections", "There are exactly ten ways of selecting three from five, `12345`:\r\n\r\n> 123, 124, 125, 134, 135, 145, 234, 235, 245, and 345\r\n\r\nIn combinatorics, we use the notation, `C(5,3) = 10`.\r\n\r\nIn general, `C(n,r) = n! / (r!(n?r)!)` ,where `r <= n, n! = n * (n?1) * ... * 3 * 2 * 1`, and `0! = 1`.\r\n\r\nIt is not until `n = 23`, that a value exceeds one-million: `C(23,10) = 1144066`.\r\n\r\nHow many, not necessarily distinct, values of  `C(n,r)`, for `1 <= n <= 100`, are greater than one-million?", "v ###    ####################################################\r\n         ####################################################\r\n>190p191p020p130pv                 >40g9+30g2%!g40g8+30g2%!g+vv!g!%2g03+9g04`**<\r\n>30g:\"d\"-!#v_1+:30p2/40p>30g40g2*>-|                         >:40g9+30g2%p\"}}@\"^\r\n^          >#<$ #<20g.@            >40g8+30g2%!g2*           ^>$40g9+1-30g2%!g!v\r\n                      >30g40g2* -^v                                _v#!_v#!_v#!<\r\n             ^       _^#!p04:-1g04<p%2g03+9g040p02++1!!-*2g04g03g02$<  $<  $<", "*That* is the kind of problem I really like. There is a lot of depth in the solution and a proper algorithm solves this in no time.\r\n\r\nThe algorithm idea here is that we use the properties of [Pascal\'s Triangle](http://en.wikipedia.org/wiki/Pascal%27s_triangle).\r\nAs you probably know this triangle starts at its top with a `1`. Then every cell is calculated as the sum of the two cells above it.\r\n\r\n~~~\r\ncell[y][x] = cell[y-1][x-1] + cell[y-1][x]\r\n~~~\r\n\r\n![Animated GIF of Pascals Triangle. (c) by Wikimedia Foundation](http://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\r\n\r\nWhen we calculate `C(n, r)` this is nothing more than the number at row *n* and column *r*.\r\n\r\nSo what we do is build [Pascal\'s Triangle](http://en.wikipedia.org/wiki/Pascal%27s_triangle) up to a height of one-hundred and look at the cells with values greater than one million.\r\nThe obvious problem is that the numbers grow extremely big, and sooner or later *(probably sooner)* the numbers will overflow. So what we do is use a little trick:  \r\nAs soon as a cell is over `1 000 000` we mark her *(= put a zero in that cell)*. When we create a new cell out of its two parents we check if one of the parents has the mark *(= is zero)* and then the children gets also marked. Because if one of the parents (or both) is over one million then all of its children will also be over one million.\r\n\r\nAnother \"trick\" is that we don\'t need to remember the whole triangle, only the current and the last row are important. So we have two \"arrays\" each representing a row and after every cycle the two change roles. The *lastRow* becomes the *currentRow* and vice versa. In Befunge we can do this simply by placing the two arrays on top of each other and accessing them with `y = row%2` or `y = (row+1)%2`.\r\n\r\nThere is one last optimisation I have done and this one will allow us to fit our program in the 80x25 Befunge-93 size restrictions.  \r\nThe triangle is symmetric and we can only look at one half of it. But we have to be aware of the fact that now every found number counts two times (one for each side) **except** it\'s exactly in the middle. ALso if we want to calculate the value of the middle cell we can\'t take the value of the right parent (this one does not exist / was never calculated), but because of it\'s symmetric properties we can just take the left one two times.\r\n\r\n~~~\r\nfor(int row = 2; row <= NMAX; row++)\r\n	for(int col = (row/2); col > 0; col--)\r\n	{\r\n		if (2*col == row)\r\n			matrix[row % 2][col] = matrix[(row + 1) % 2][col - 1] * 2;\r\n		else\r\n			matrix[row % 2][col] = matrix[(row + 1) % 2][col] + matrix[(row + 1) % 2][col - 1];\r\n		\r\n			\r\n		if (matrix[row % 2][col] > 1000000 || matrix[(row + 1) % 2][col] == 0 || matrix[(row + 1) % 2][col - 1] == 0)\r\n		{\r\n			count += (2 * col == row) ? 1 : 2;\r\n			matrix[row % 2][col] = 0;\r\n		}\r\n	}\r\n~~~\r\n\r\n\r\n> **Tip:** \r\n>\r\n> Run this code with [BefunExec](https://github.com/Mikescher/BefunExec) on the 50kHz speed setting - it looks quite cool in action.", 0, 372790, 125, 80, 7, 4075);
	Do(54, "Poker hands", "\r\n\r\nIn the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:\r\n\r\n* High Card: Highest value card.\r\n* One Pair: Two cards of the same value.\r\n* Two Pairs: Two different pairs.\r\n* Three of a Kind: Three cards of the same value.\r\n* Straight: All cards are consecutive values.\r\n* Flush: All cards of the same suit.\r\n* Full House: Three of a kind and a pair.\r\n* Four of a Kind: Four cards of the same value.\r\n* Straight Flush: All cards are consecutive values of same suit.\r\n* Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.\r\n\r\nThe cards are valued in the order:\r\n2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.\r\n\r\nIf two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives (see example 1 below). But if two ranks tie, for example, both players have a pair of queens, then highest cards in each hand are compared (see example 4 below); if the highest cards tie then the next highest cards are compared, and so on.\r\n\r\nConsider the following five hands dealt to two players:\r\n\r\nHand   | Player 1         | Player 2            | Winner\r\n-------|------------------|---------------------|------------\r\n       |                  |                     |\r\n1      | 5H 5C 6S 7S KD   | 2C 3S 8S 8D TD      | Player 2\r\n&nbsp; | Pair of Fives    | Pair of Eights      | &nbsp;\r\n       |                  |                     |\r\n2      | 5D 8C 9S JS AC   | 2C 5C 7D 8S QH      | Player 1\r\n&nbsp; | Highest card Ace | Highest card Queen  | &nbsp;\r\n       |                  |                     |\r\n3      | 2D 9C AS AH AC   | 3D 6D 7D TD QD      | Player 2\r\n&nbsp; | Three Aces       | Flush with Diamonds | &nbsp;\r\n       |                  |                     |\r\n4      | 4D 6S 9H QH QC   | 3D 6D 7H QD QS      | Player 1\r\n&nbsp; | Pair of Queens   | Pair of Queens      | &nbsp;\r\n&nbsp; | Highest card Nine| Highest card Seven  | &nbsp;\r\n       |                  |                     |\r\n5      | 2H 2D 4C 4D 4S   | 3C 3D 3S 9S 9D      | Player 1\r\n&nbsp; | Full House       | Full House          | &nbsp;\r\n&nbsp; | With Three Fours | with Three Threes   | &nbsp;\r\n\r\nThe file, poker.txt, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1\'s cards and the last five are Player 2\'s cards. You can assume that all hands are valid (no invalid characters or repeated cards), each player\'s hand is in no specific order, and in each hand there is a clear winner.\r\n\r\nHow many hands does Player 1 win?\r\n", ">096p\"~\"8*1+04p906p036p 116p   v \r\n\r\n###############\r\n\r\n$\r\n$  $\r\n$$ $$$$$ $\r\n$$\r\n\r\n8C TS KC 9H 4S 7D 2S 5D 3S AC  \r\n5C AD 5D AC 9C 7C 5H 8D TD KS    \r\n3H 7H 6S KC JS QH TD JC 2D 8S  \r\nTH 8H 5C QS TC 9H 4D JC KS JS               >\"A\"v\r\n7C 5H KC QH JD AS KH 4C AD 4S  >36g06gg36g3%|\r\n5H KS 9C 7D 9H 8D 3S 5D 5C AH               >\"0\"-55+\\:89+-!#v_:39*-!#v_:\"!\"-!#v_ :892*+-!#v_:66*-!#v_\\$v\r\n6H 4H 5C 3H 2H 3S QH 5S 6S AS                   >          v>$1+    0>$1+    0>$1+       0>$1+    0>$1+v\r\nTD 8C 4H 7C TC KC 4C 3H 7S KS          vp63+1g63           >#     #<                                   v\r\n7C 9C 6D KD 3H 4C QS QC AC KH  |-g40g60<                           |-*65g63                 pg60-/3:g63<\r\nJC 6S 5H 2H 2D KD 9D 7C AS JS  8       ^p60+1g60p630 pg60-/3:g63\" \"<\r\nAD QH TH 9D 8H TS 6D 3S AS AC  0                 v  61g64p64+**\"23\"!!+++!-g65**+\"$~ll\"!-g65*9*93!-g<\r\n2H 4S 5C 5S TC KC JD 6C TS 3C                    g   v$_v#!\\-1:                                   <6       v<\r\nQD AS 6H JS 2C 3D 9H KC 4H 8S                    7  > 3*> :2g:1-*48*8**46g+46p ::2g\\1+2g*!!35g+35p^5       1g\r\nKD 8S 9S 7C 2S 3S 6D 6S 4H KC  6                 p  5>46g66g+76g35**+35g4-!\"A\'\"*5+*+7::*:**56g-!48*^       +2\r\n3C 8C 2D 7D 4D 9S 4S QH 4H JD  p        >         v p  v_v#!\\-1:<  v                 _v#!%+55p63:+2g63p2g50<g\r\n8C KC 7S TC 2D TS 8H QD AC 5C  >16g!:16p|p61:!g61<>#5 88+> :0\\2p^  #                               >g6v     5\r\n3D KH QD 6C 6S AD AS 8H 2H QS           >06g1+06pv^ 3  >$$  16g55+*36p046p156p066p076p>36g06gg05p3v5v6<     0\r\n6S 8D 4C 8S 6C QH TC 6D 7D 9D  vg71g70 _v#-g40g60<p ^0             <                  vg65gg60+1g6<0p       ^  p67g50<\r\n2S 8D 8C 4C TS 9S 9D 9C AC 3D  >`96g+96v>07g17g`96 g+:96p.@                           >*56p05g66g` |>05g2g!#^_05g76g`|\r\n3C QS 2S 4H JH 3D 2D TD 8S 9H          >          ^                                                >^       ^        <\r\n5H QS 8S 6D 3C 8C JD AS 7H 7D\r\n.  .  .\r\n.  .  .\r\n.  .  .\r\n.  .  .", "Yep, I *hate* this problem.  \r\nNot only is there an enormous amount of input data that makes our program huge in size.\r\nBut it contains a lot of different cases, rules and logic that needs be represented in our program\r\n\r\nBut none the less I tried to come up with an compact algorithm for scoring a set of cards\r\n\r\n~~~\r\nGet(@\"https://projecteuler.net/project/resources/p054_poker.txt\")\r\n	.Where(p => GetScore(p.deck_1) > GetScore(p.deck_2))\r\n	.Count()\r\n	.Dump();\r\n~~~\r\n\r\n~~~\r\nint GetScore(Card[] cards) {\r\n	List<long> SUMS = new List<long>{ H*H*H*H*H, C*C*C*C*C, S*S*S*S*S, D*D*D*D*D };\r\n\r\n	int[] array = new int[15];\r\n	int score = 0;\r\n	int flushSum = 1;\r\n	int highCard = 0;\r\n	int highGroup = 0;\r\n	int straightIndex = 0;\r\n\r\n	foreach(Card c in cards) {\r\n		highCard = Math.Max(highCard, c.value);\r\n		flushSum *= c.suit;\r\n		if (array[c.value] > 0)\r\n			highGroup = Math.Max(highGroup, c.value);\r\n		array[c.value]++;\r\n	}\r\n\r\n	for(int i = 1; i < 15; i++)\r\n	{\r\n		score += (array[i]-1)*(array[i])*256;\r\n		\r\n		if (array[i] > 0 && array[i-1] > 0)\r\n			straightIndex++;\r\n	}\r\n	score += highCard;\r\n	score += highGroup * 15;\r\n\r\n	if (straightIndex == 4)\r\n		score += 2540;\r\n	if (SUMS.Contains(flushSum))\r\n		score += 2550;\r\n		\r\n	return score;\r\n}\r\n~~~\r\n\r\nThe different values are carefully crafted in such a way, that you can compare the score of two hands and get the winner\r\n\r\n Card                | Calculation    | Score\r\n---------------------|----------------|---------------------------------------------\r\nHigh Card            | {0-14} * [1]   | = {0-14}\r\nHigh Card (in Group) | {0-14} * [15]  | = {0-210}\r\nOne Pair             | 2 * [256]      | = 512  *(+ HighCard)* *(+ HighGroup)*\r\nTwo Pairs            | 4 * [256]      | = 1024 *(+ HighCard)* *(+ HighGroup)*\r\nThree of a Kind      | 6 * [256]      | = 1536 *(+ HighCard)* *(+ HighGroup)*\r\nStraight             | [2540]         | = 2540 *(+ HighCard)* *(+ HighGroup)*\r\nFlush                | [2550]         | = 2550 *(+ HighCard)* *(+ HighGroup)*\r\nFull House           | 10 * [256]     | = 2560 *(+ HighCard)* *(+ HighGroup)*\r\nFour of a Kind       | 12 * [256]     | = 3072 *(+ HighCard)* *(+ HighGroup)*\r\nStraight Flush       | [2540] + [2550]| = 5090 *(+ HighCard)* *(+ HighGroup)*\r\nRoyal Flush          | [2540] + [2550]| = 5090 *(+ HighCard)* *(+ HighGroup)*\r\n\r\nOne last side note: A **royal flush** is not really a independent rank. Because of the \"highest card in the rank\" rule a royal flush is always better than a straight flush (because the highest card is an ace)\r\n", 1, 5949695, 2543, 118, 1009, 376);
	Do(55, "Lychrel numbers", "If we take 47, reverse and add, `47 + 74 = 121`, which is palindromic.\r\n\r\nNot all numbers produce palindromes so quickly. For example,\r\n\r\n~~~\r\n349 + 943 = 1292,\r\n1292 + 2921 = 4213\r\n4213 + 3124 = 7337\r\n~~~\r\n\r\nThat is, 349 took three iterations to arrive at a palindrome.\r\n\r\nAlthough no one has proved it yet, it is thought that some numbers, like `196`, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, `10677` is the first number to be shown to require over fifty iterations before producing a palindrome: `4668731596684224866951378664` (53 iterations, 28-digits).\r\n\r\nSurprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is `4994`.\r\n\r\nHow many Lychrel numbers are there below ten-thousand?\r\n\r\n> NOTE: Wording was modified slightly on 24 April 2007 to emphasise the theoretical nature of Lychrel numbers.\r\n", "v                           v-1\\+g02<\r\n0          v/+55\\+g01\\p01%+<        $  v/+55\\+g01\\p01%+<\r\n>\"}P\"*>::0\\>:!#v_\\55+*\\:55 ^>:!#v_\\::0\\>:!#v_\\55+*\\:55 ^\r\n    >$ .@      >$+38*   #v  ^#   <  |-p02:$<\r\n    ^_^#!:-1             <\\+1\\$$<^$$<", "Not much to say about this one. I reuse the isPalindrome code from P-36 and bruteforce through all the numbers.  \r\nI think it would be really useful to cache the intermediate results - but our befunge space is too small for such data structures :/", 0, 10470329, 2215, 56, 5, 249);
	Do(56, "Powerful digit sum", "A googol (`10^100`) is a massive number: one followed by one-hundred zeros; `100^100` is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.\r\n\r\nConsidering natural numbers of the form, ab, where `a, b < 100`, what is the maximum digital sum?", "vXXX ######################################################################\r\n XXX ######################################################################\r\n     ######################################################################\r\n\r\n>        \"c\"v  _v#   `*95:<\r\nv+\"I~\"<\\\"c\":<       >:55+%|\r\n>1-:0\\:\"F\"%v    >1-:|:-1  <\r\n|:p/\"F\"\\+5 <@.g1$#2$<\r\n>$188*2p020p10p>030p\"~J\"+>1-:::\"F\"%5+\\\"F\"/g10g*20g+:55+/v\r\n     >21p > 1-:|^$<      |:p/\"F\"\\+5%\"F\":\\p03+g03:%+55p02<\r\n     ^g03_^#`g1># ^#2g03$<", "Here we iterate through the values of a (1..99) and do (manually) the long multiplication.  \r\nBecause we have to implement the multiplication manually we get every result from a^1 to a^99 an can easily get the digitsum for these.\r\nThen we remember the maximum digitsum and vòila, problem solved.\r\n\r\nA few optimizations:\r\n - We ignore values where `a%10 == 0`, because these result in numbers consisting mostly of zeroes, and those will never have a high digitsum\r\n - We also ignore values for a<45, because the numbers are just to short to be really significant.", 0, 62461749, 13915, 75, 11, 972);
	Do(57, "Square root convergents", "It is possible to show that the square root of two can be expressed as an infinite continued fraction.\r\n\r\n~~~\r\nsqrt(2) = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...\r\n~~~\r\n\r\nBy expanding this for the first four iterations, we get:\r\n\r\n~~~\r\n1 + 1/2                         = 3 /2  = 1.5\r\n1 + 1/(2 + 1/2)                 = 7 /5  = 1.4\r\n1 + 1/(2 + 1/(2 + 1/2))         = 17/12 = 1.41666...\r\n1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...\r\n~~~\r\n\r\nThe next three expansions are `99/70`, `239/169`, and `577/408`, but the eighth expansion, `1393/985`, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.\r\n\r\nIn the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?\r\n", "v\r\n\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n ###############################################################################\r\n\r\n>77*8*2+>:0\\:\"O\"%1+\\\"O\"/2+p:0\\:\"O\"%1+\\\"O\"/8+p:0\\:\"O\"%1+\\\"O\"/72*+p:0\\:   v\r\n        |+1:-1p+*84/\"O\"\\+1%\"O\":\\0:p++*298/\"O\"\\+1%\"O\":\\0:p+*45/\"O\"\\+1%\"O\"<\r\n        >$ 1\"O\"6p1\"O\"62*p1\"O\"56*p v\r\nv                                 <\r\n>60*70p61*80p62*90p60*71p61*81p v                  >   0>$                 v\r\nv*\"o\"9 p040p121p111p19*26       <                  ^p11_^#`g11 :-g02*5\"O\"<\r\n> 010p\"O\"5*>1-:::20p:\"O\"%1+\\\"O\"/70g2++g\\:\"O\"%1+\\\"O\"/80g2++g2*10g++:55+%:#^_v\r\n           ^                              _v#:p01/+55p++2g09/\"O\"\\+1%\"O\":g02<\r\n v    p09%+99+6g09p08%+99+6g08p07%+99+6g07$<           >   0>$                 v\r\n                                                       ^p12_^#`g12 :-g02*5\"O\"<\r\n >010p\"O\"5*>1-:::20p:\"O\"%1+\\\"O\"/71g54*++g\\:\"O\"%1+\\\"O\"/81g54*++g2*10g++:55+%:#^_v\r\n           ^                                _v#:p01/+55p++*45g19/\"O\"\\+1%\"O\":g02<\r\n v      p19%+99+6g19p18%+99+6g18p17%+99+6g17$<\r\n >11g21g`!#v_40g1+40pv\r\n|:       -1<         <\r\n>$40g.@", "I was a bit lazy with this problem. The first thing i did was search on OEIS for the numerator and denominator sequences.\r\nAnd I found both, they are **A123335** and **A000129**.\r\nBut still there are two mayor problems:\r\n - First these are recursive functions, so we need to store the last and the second last result. This is again the reason why our programs exceeds the Befunge-93 size restrictions. We need three fields for the numerator and three for the denominator (Current value | Last value | Second last value).\r\n - Second the numbers become big. Like *really* big. The last values get close to four hundred digits. So - again - we need to do the calculations manually *(long multiplication and addition)*\r\n\r\nIn the end we have a reasonable fast program with six 79*5 arrays for value storage.", 0, 87464066, 15023, 80, 54, 153);
	Do(58, "Spiral primes", "Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.\r\n\r\n~~~\r\n37 36 35 34 33 32 31\r\n38 17 16 15 14 13 30\r\n39 18 05 04 03 12 29\r\n40 19 06 01 02 11 28\r\n41 20 07 08 09 10 27\r\n42 21 22 23 24 25 26\r\n43 44 45 46 47 48 49\r\n~~~\r\n\r\nIt is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of `8/13 = 62%`.\r\n\r\nIf one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed. If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below `10%`?", "v####\r\nv##\r\nv#\r\nv###     >             >             >      >$0v  \r\n                >             >              $1v  \r\n  >::2\\`#^_:2-!#^_:2%!#^_:9\\`#^_:3%!#^_:5%!#^_1 :v\r\n2>^<v\\                      p21:+1g21:_v#-3 <p2 1<\r\n1  p>:11p1-0\\>:2% !#v_v    v ++!!+1-g< #    ^ < >v\r\n3  3         ^\\+1\\/2< \\    >3-#v_$$  1>12g\\  !|>|\r\np 31 vp01p03p04 g11p12<        >:*11v1 >$1   #$^\r\n1 p+ >120pv        v%g04*<v-1\\    %g<^ \\!!-1:<$0\r\n2 32 vg030<  v-1\\  < >10g^   >\\:::*11  g%1-!\\^>^\r\n3 3g     >$1\\> :#v_ $ 21g >:#^_$1-!!  ^\r\np 03 >:!#^_\\1+\\2v\\ ^_^#!%2/\\g03p<  v    p33+1g33 <\r\n> ^1 ^p02*2g02/ <>:*40g%20g2/:20^\r\n ^_^#%4g32+g31_v#`\\*+55g33p32:+1g32<            < \r\n @.+3*2/4-2g32$<", "It\'s obvious that the bottleneck of this program is the primality test.\r\nThe numbers become here too big to create a sieve and \"normal\" prime testing takes too long.\r\nSo we use the [Miller-Rabin primality test](http://en.wikipedia.org/wiki/Miller-Rabin_primality_test) that I implemented a while ago (thank [mathblog.dk](http://http://www.mathblog.dk)).  \r\nThe rest is just enumerating all the diagonals until `primes*10<all`", 0, 78283096, 12199, 50, 17, 26241);
	Do(59, "XOR decryption", "Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase `A = 65,` `asterisk (*) = 42`, and `lowercase k = 107`.\r\n\r\nA modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, `65 XOR 42 = 107`, then `107 XOR 42 = 65`.\r\n\r\nFor unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both \"halves\", it is impossible to decrypt the message.\r\n\r\nUnfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.\r\n\r\nYour task has been made easy, as the encryption key consists of three lower case characters. Using [cipher.txt](https://projecteuler.net/project/resources/p059_cipher.txt) *(right click and \'Save Link/Target As...\')*, a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.", ">20g3*10gg\"0\"-55+*20          v                                   \r\n v\"d\"\\+8%\"d\":g03+-\"0\"gg01+1*3g<                                   \r\n >/p30g1+30p20g1+:93+-#v_$10g1v                                   \r\n|-2+!-1g02!-\"u\"  g01p02<0p01+ <                                   \r\n                                                                  \r\n                      v1p12<vp12/2g12p11/2g11+*p13*2:g <          \r\n>051p > 061p > 51g61g   11p^>11g21g+!#v_11g2%21g2%+2%31^          \r\n      |- **88 2p15:<  > 31p0^         >51g\"m\"+61gp     v          \r\nv\"+~h\"<      |                         -**882 p16:+1g16<          \r\n+            >51g1+^                                              \r\n*   v                                                          <  \r\n>13p>13g:1-13p#v_                                                v\r\nv+\"a\"%+*298:g31<                                       >      >^ 5\r\n>12p892*+/:892*+%\"a\"+22p892*+/\"a\"+32pv                 $      $  5\r\nv p430                               <                 $      $  6\r\n>014p 55*6*8* >:3%1+24p::\"d\"%8+\\\"d\"/g\"m\"+24g2gg :\" \"\\`#^_:\"~\"`|  8\r\n              ^-1                        _v#-\" \"_v#-9p41+1:g41<  *\r\n                                                 >$$           ^ *\r\nv                                         <      >$            ^ *\r\n                                          >      $             ^ 1\r\n>:3%1+24p::\"d\"%8+\\\"d\"/g\"m\"+24g2gg  :\" \"\\`#^_:\"~\"`|               5\r\n^-1_v#:                                   _v#-\"e\"<               p\r\n   ^  :                            p43+1g43<                     0\r\n    >$34g23g`#v_                                               ^ 2\r\n              >34g23p 32g22g12g 43p53p63p                      ^ 5\r\n                                                                 p\r\nv                                                                <\r\nv                                                     p51-1<      \r\n>15g:\"d\"%8+\\\"d\"/g\"m\"+15g3%4+3gg:25g+25p15g:\"d\"%8+\\\"d\"/p15g:|      \r\n                                                           >$25g.@\r\n", "This task had a lot of Befunge specific problems, but first let\'s look at the solving strategy:\r\n - We go through all `26^3` passwords and test look if they generate illegal characters (smaller 32 or bigger 127).\r\n - We also see if one of the first twelve characters is a space, assuming the first word is no longer than twelve characters.\r\n - The leaves us with around one-hundred viable passwords.\r\n - We use the fact that in the English language the letter `e` is pretty common and take the password with the highest count of `e`.\r\n - The rest is just decrypting the text and counting the values.\r\n\r\nNow to our Befunge specific problems:  \r\n - First we need to input the raw data. Our best call is inserting the data directly into the program and then parsing it in the first step into an array.\r\n - The next problem is the missing xor operator. To perform an xor operation we need to go through all bits and xor them individually (`a xor b == (a+b) % 2`). This is an extremely pricey operation. And to speed this up we generate an complete 128x128 xor look up-table with all possible xor operations.\r\n\r\nAll in all a not really optimal problem for Befunge but still a fun challenge", 1, 37085853, 6302, 273, 128, 107359);
	Do(60, "Prime pair sets", "The primes `3`, `7`, `109`, and `673`, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime. For example, taking `7` and `109`, both `7109` and `1097` are prime. The sum of these four primes, `792`, represents the lowest sum for a set of four primes with this property.\r\n\r\nFind the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.", "vXXXX  /#...##     ####\r\n XXX   #     #     ####\r\n XXXXXX.     .     ####\r\n XX    .     .     ####\r\n XXX   .     .     ####\r\n XXXXX #     #     ####\r\n XXX   ##...##     ####\r\n\r\n>55+12p   \"d!\"*22p   26522g+++62p   22g:*52p   12g22g*42p   523p v                                       \r\n                               v                             p232<   >032p     v    \r\nv              p0+1g26p0g26:\" \"<                                    _^#`g23g24<\r\n>\"X\"32g:12g%62g+\\12g/p32g>32g+:42g\\`         #v_$>32g1+:32p:12g%62g+\\12g/g\" \"-|                          \r\n                         ^p/g21\\+g26%g21:\\\" \":<  ^                            <\r\nv                                                                              <\r\n >52g     >1-:0\\:22g%9+\\22g/1+pv                                                                         \r\n          |:                   <\r\n v       $<\r\n>22g1+   >1-       :0\\8\\p     v\r\n         |:                   <\r\nv       $<\r\n >22g     >1-:0\\9+0p           v\r\n          |:                   <\r\n v       $<\r\n>0  113p >  ::12g%62g+\\12g/g\"X\"-#v_:13g8+0p:713gp22g13g1+:13p\\`#v_v                                      \r\n         |-g24:+1                <                                <\r\nv       $<                                                      <\r\n>114p  024p  \"@@@@` \"+****34p  015p 025p 035p 045p 055p 065p     v                                       \r\nv                                                       <        <                                       \r\n>14g#v_34g.@\r\n     >14g1+5g1+:14g1+5p22g-#v_14g1-14p24g714g1+5g1+g-24p^                                                \r\n    vg41g32g+1g5+1g417g42g43<\r\n    >-*+`#v_14g1-14p24g714g1+5g1+g-24p                  ^                                                \r\n    v-1g41<\r\n    :>:1+5g1+14g1+5g9+\\g#v_$                            ^                                                \r\n    >|:-1                <\r\n     $\r\n     >14g1+5gv                                                >             >             >      >$0v    \r\n     v       <                                 >55+*\\:v              >             >              $1v\r\n     >:1+8\\g#v_:::1\\1+8\\p36p9+0g26p1+v>:9+0g:26 g>\\:#v_$+:2\\`#^_:2-!#^_:2%!#^_:9\\`#^_:3%!#^_:5%!#^_1 :v\r\n                                  v2:<         ^\\/+55<   v\\                      p13:+1g13:_v#-3 <p1 3<\r\n             $                    >2g-|<                 >:11p1-0\\>:2% !#v_v    v ++!!+1-g< #    ^ <   >v\r\n     v       <                       $<-                          ^\\+1\\/2< \\    >3-#v_$$  1>31g\\  !|>  |\r\n                                       g                  vp01p03p04 g11p12<        >:*11v1 >$1   #$^  :\r\n                                       2                  >120pv        v%g04*<v-1\\    %g<^ \\!!-1:<$0  0\r\n                                       2                  vg030<  v-1\\  < >10g^   >\\:::*11  g%1-!\\^>^\r\n                                       :                      >$1\\> :#v_ $ 21g >:#^_$1-!!  ^\r\n                                       +                  >:!#^_\\1+\\2v\\ ^_^#!%2/\\g03p<\r\n                                       1                  ^p02*2g02/ <>:*40g%20g2/:20^\r\n                                              v                                            g62\\g62g0+9: <\r\n                                       ^                                                      p+1g63+9\\<<\r\n                                                              >             >             >      >$0v    \r\n                                               >55+*\\:v              >             >              $1v\r\n                                              > \\>\\:#v_$+:2\\`#^_:2-!#^_:2%!#^_:9\\`#^_:3%!#^_:5%!#^_1 :v\r\n                                               ^\\/+55<   v\\                      p13:+1g13:_v#-3 <p1 3<\r\n                                                         >:11p1-0\\>:2% !#v_v    v ++!!+1-g< #    ^ < >:1^\r\n                                                                  ^\\+1\\/2< \\    >3-#v_$$  1>31g\\  !|>|\r\n                                                          vp01p03p04 g11p12<        >:*11v1 >$1   #$^>:0^\r\n                                                          >120pv        v%g04*<v-1\\    %g<^ \\!!-1:<$0\r\n                                                          vg030<  v-1\\  < >10g^   >\\:::*11  g%1-!\\^>^\r\n                                                              >$1\\> :#v_ $ 21g >:#^_$1-!!  ^\r\n                                                          >:!#^_\\1+\\2v\\ ^_^#!%2/\\g03p<\r\n                                                          ^p02*2g02/ <>:*40g%20g2/:20^\r\n             >24g714g1+5g1+g+24p14g1+14p14g5g14g1+5p v                                                   \r\n     >14g23g-|                    >24g714g1+5g1+g+34p v\r\n             >34g24g714g1+5g1+g+`#^_                  >14g1-14p24g7 v                                    \r\n^                                                    <p42-g+1g5+1g41<", "Wow, so this is now officially my biggest (in terms of file size) befunge program.\r\nThe file has around ten megabyte. And probably also in terms of unique variables (26 variables plus two 2D-arrays)\r\n\r\nThe problem was also not that *befunge-compatible*.\r\nMy solution is pretty similar with the one from [MathBlog](http://www.mathblog.dk/project-euler-60-primes-concatenate/).\r\nWe generate primes from `1` to `3300` and save verified pairs in an Hashmap.\r\nAnd when I say Hashmap I mean an *fucking* `3000x3000` array where every possible pair has an field (yay for befunge).\r\n\r\nI had to use quite a few codesnippets from older project:\r\nMy standard [sieve of eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes), an implementation of the [Miller-Rabin primality test](http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test) and method to [concatenate two numbers](http://www.mathblog.dk/files/euler/Problem60.cs).\r\n\r\nIn the end is to say that in befunge the program size is normally an good indicator for the runtime (not really, but its kinda correct for all my programs).\r\nSo as you probably guessed this program takes a pretty loooooong time to complete.\r\nI even had to make some aspects dynamic so I could test it with only 4 concatenated primes (and an sieve of size 9000).\r\nOtherwise it would be impossible to debug it (or at least very tiresome).", 1, 8609996835, 2032350, 3323, 3360, 26033);
	Do(61, "Cyclical figurate numbers", "Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers \r\nare all figurate (polygonal) numbers and are generated by the following formulae:\r\n\r\n~~~\r\nTriangle        P3,n=n(n+1)/2    1, 3, 6, 10, 15, ...\r\nSquare          P4,n=n2          1, 4, 9, 16, 25, ...\r\nPentagonal      P5,n=n(3n?1)/2   1, 5, 12, 22, 35, ...\r\nHexagonal       P6,n=n(2n?1)     1, 6, 15, 28, 45, ...\r\nHeptagonal      P7,n=n(5n?3)/2   1, 7, 18, 34, 55, ...\r\nOctagonal       P8,n=n(3n?2)     1, 8, 21, 40, 65, ...\r\n~~~\r\n\r\nThe ordered set of three 4-digit numbers: `8128, 2882, 8281`, has three interesting properties.\r\n\r\n - The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).\r\n - Each polygonal type: triangle (`P(3,127)=8128`), square (`P(4,91)=8281`), and pentagonal (`P(5,44)=2882`), is represented by a different number in the set.\r\n - This is the only set of 4-digit numbers with this property.\r\n\r\nFind the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: \r\ntriangle, square, pentagonal, hexagonal, heptagonal, and octagonal, \r\nis represented by a different number in the set.", "v$$  ### ---------------------------------------------------------------- ###\r\n $$  ### ---------------------------------------------------------------- ###\r\n $   ### ---------------------------------------------------------------- ###\r\n $   ### ---------------------------------------------------------------- ###\r\n $   ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n     ### ---------------------------------------------------------------- ###\r\n           v_v#!          _v#                       <1      g02$$<\r\n  #####    1 v  p02g01_v#! #  g02$_v#!:p\\+9%*88g02 <0\r\n> # 6 # 10p   288** 20p>20g1-20p10g>1-:0\\2*20g88*/+^^ $<0p03+1g03 p+*2g02/*88g<\r\n  #####    0 >20g1-20p030p0>1+::::*\\-2/20g1+*+:\"}\"8*\\`#^_:\"ec\"*`#^_30g88*%9+30^\r\n           >g>1-:0\\5\\p:0\\6\\p:0\\7\\p:#v_$  01-60p011p v\r\nv<         $_^#!:                   <0              <     <       <$$<\r\n>611gg1+611gp611gg12p511gg13p12g10g-!#v_13g\"_ \"+`#v_712gg#^_13g88* %9+13g88*/12v\r\n^<pg115+1gg115pg116-10                <v88g-1g115+9%*88g-1g115g11_^#g41p41g+*2g<\r\n^<pgg11670p11-1g11                     *#        $<v05+9%*8        8g05%\"d\"g41<\r\n                                       >/611g1-g2*+g\"d\"%14g\"d\"/-*#^_10g1-11g`!|\r\n^<pg1150pg116-10p11+1g11pg2171                                                <\r\n>2*+g:.+55+,21g1+:21p10g-#v_\" =  \",,,,.@           >88*/60g2*+g\"d\"/-#^_v\r\n^gg126/*88gg125+9%*88gg125<0p120                                       <", "Pretty cool problem, I have to say.\r\n\r\nIt\'s one of these problem that you can easily make dynamic. In the middle-left of this program you see the number `6` surrounded with `#`.\r\nThis is the \"amount of resulting numbers\" parameter of our program. For this Euler-problem you need to set this to `6`.\r\nBut for debugging purposes I mostly tested it with `3`. And if you want you can try it out with bigger numbers `7` or `8`.\r\n*(But then you need to move the code down a bit - otherwise the cache-part will intersect with the code-part)*.\r\n\r\nWith this number we first generate all the [polygon-numbers](https://en.wikipedia.org/wiki/Polygonal_number) from `3` to `SIDES_COUNT + 2` with the formula `(n-2) * (n^2 - n)/2 + n`.\r\nThen we go recursively through all these numbers. First we test triangle[1] with square[1], then with square[2] and so on. *(The recursion is - as always - just a stack and a stack pointer)*.\r\n\r\nA last note: This was *(until now)* probably the hardest program to fit in the befunge 80x25 size restriction.\r\nI *barely* managed to get it (and now its exactly 80x25) and I had to use quite some trickery.", 0, 50105245, 14414, 80, 25, 28684);
	Do(62, "Cubic permutations", "The cube, `41063625 (345^3)`, can be permuted to produce two other cubes: `56623104 (384^3)` and `66430125 (405^3)`. \r\nIn fact, `41063625` is the smallest cube which has exactly three permutations of its digits which are also cube.\r\n\r\nFind the smallest cube for which exactly five permutations of its digits are cube.", "v $ # ... #\r\n  $ #     #\r\n  $ .     .\r\n    .     .\r\n  $ .     .\r\n  $ .     .\r\n    #     #\r\n    # ... #\r\n  v                                          _v#!:p/g42\\+ <\r\n>3 28p        \"K\":    24p    88+:    25p*:26p >1-:0\\:24g%4^\r\nv <                           v+1           <\r\n0                                           |-g02<\r\n>1+:::**:22p 0\\v   v\\-1 <>20p0>:3*:24g%4+\\24 g/g:|\r\n$         v+55:<>\\1>9*\\:|:                      @$$.g/g42\\+4%g42:+1$       <\r\n          >%\\:#^|#/+55\\$<+                  >    3*:2+:24g%4+\\24g/g1+:28g-!|\r\n         >$ #\\>#<>\\# :#+_^                       >*::2v   vp/g42\\+4%g42:+2\\<\r\n^p/g42\\+4%g42:+2\\1p/g42\\+4%g42:+1\\g22p/g42\\+4%g42:\\g0 <\r\n^                                                         <", "Only after at least sixty-two mathematical programs in befunge you will **truly** appreciate a hashtable.\r\n\r\nFor real, everything would be so much better if I could retrieve this stuff in `O(1)`.\r\n\r\nMy approach is pretty straight-forward. We calculate an permutation-insensitive hash.\r\nThen store them together with the times it appeared in a hashmap *(I mean a list -.-)*.\r\nNow we just go through all the cubes until a single hash appeared five times. In C# with a Dictionary this takes around 10ms.", 1, 952323293, 363264, 505, 58, 127035954683);
	Do(63, "Powerful digit counts", "The 5-digit number, `16807=7^5`, is also a fifth power.\r\nSimilarly, the 9-digit number, `134217728=8^9`, is a ninth power.\r\n\r\nHow many n-digit positive integers exist which are also an nth power?", "v XXXX   #######################################################################\r\n  XX\r\n                          v1\\1p12::+1   \\+g2<\r\n0                 v9p03p02<         \\g12:+1<^2\\p22_v\r\n1          >v     v              <  v-\\\"P\"<       :$\r\n>        :v1v>0p>9>:\"0\"\\0p1+:\"O\"-|>:0g\"0\"-||!`g12<-$\r\n          :p\\3v p050p04\"O\"<p0\\\"1\"<^+>#1 $#< :21g-|\\.\r\n          211p> 40g0g\"0\"-2 0g*50g+:55+%\"0\"v>$55+0v+@\r\n          >^20|-8p04:-1g04 p05/+5 #5p0g04+<>5#$5#<^\r\n            >^>30g1-:30p #^_9     ^", "After all the previous programs, this one is surprisingly ... dense (the main code-block is 54x8).\r\n\r\nThe algorithm is quickly explained for each length n we calculate the numbers `1^n`, `2^n` ... until `9^n` and see which have a length of `n`.\r\n(From `10^n` upwards the condition is impossible, because `10^n` has `(n+1)` digits).\r\n\r\nThe main problem is that the numbers exceed Int64. So we need to implement long multiplication ... again. (see problem 16, 20, 29, 56 and 57)", 0, 8880369, 2762, 80, 10, 49);
	Do(64, "Odd period square roots", "All square roots are periodic when written as continued fractions and can be written in the form:\r\n\r\n~~~\r\nsqrt(N) = a0 + 1 / (a1 + 1 / (a2 + 1 / (a3 + ... )))\r\n~~~\r\n\r\nFor example, let us consider `sqrt(23)`:\r\n\r\n~~~\r\nsqrt(23) \r\n = 4 + sqrt(23) - 4 \r\n = 4 + 1 / ( 1 / ( sqrt(23) - 4 ) )	\r\n = 4 + 1 / ( 1 + ( sqrt(23) - 3 ) / 7)\r\n~~~\r\n\r\nIf we continue we would get the following expansion:\r\n~~~\r\nsqrt(23) = 4 + 1/(1 + 1/(3 + 1/(1 + 1/(8 + ... ))))\r\n~~~\r\n\r\nThe process can be summarised as follows:\r\n\r\na    | Step 1                 | Step 1                  |Step 1                \r\n-----|------------------------|-------------------------|----------------------\r\n`a0` | `4`, `1/(sqrt(23) - 4` | `1*(sqrt(23) + 4) /  7` | `1 + (sqrt(23) - 3)/7`\r\n`a1` | `1`, `7/(sqrt(23) - 3` | `7*(sqrt(23) + 3) / 14` | `3 + (sqrt(23) - 3)/2`\r\n`a2` | `3`, `2/(sqrt(23) - 3` | `2*(sqrt(23) + 3) / 14` | `1 + (sqrt(23) - 4)/7`\r\n`a3` | `1`, `7/(sqrt(23) - 4` | `7*(sqrt(23) + 4) /  7` | `8 + (sqrt(23) - 4)/1`\r\n`a4` | `8`, `1/(sqrt(23) - 4` | `1*(sqrt(23) + 4) /  7` | `1 + (sqrt(23) - 3)/7`\r\n`a5` | `1`, `7/(sqrt(23) - 3` | `7*(sqrt(23) + 3) / 14` | `3 + (sqrt(23) - 3)/2`\r\n`a6` | `3`, `2/(sqrt(23) - 3` | `2*(sqrt(23) + 3) / 14` | `1 + (sqrt(23) - 4)/7`\r\n`a7` | `1`, `7/(sqrt(23) - 4` | `7*(sqrt(23) + 4) /  7` | `8 + (sqrt(23) - 4)/1`\r\n\r\nIt can be seen that the sequence is repeating. For conciseness, we use the notation `sqrt(23) = [4;(1,3,1,8)]`, to indicate that the block `(1,3,1,8)` repeats indefinitely.\r\n\r\nThe first ten continued fraction representations of (irrational) square roots are:\r\n\r\n~~~\r\nsqrt( 2) = [1;(2)],         period=1\r\nsqrt( 3) = [1;(1,2)],       period=2\r\nsqrt( 5) = [2;(4)],         period=1\r\nsqrt( 6) = [2;(2,4)],       period=2\r\nsqrt( 7) = [2;(1,1,1,4)],   period=4\r\nsqrt( 8) = [2;(1,4)],       period=2\r\nsqrt(10) = [3;(6)],         period=1\r\nsqrt(11) = [3;(3,6)],       period=2\r\nsqrt(12) = [3;(2,6)],       period=2\r\nsqrt(13) = [3;(1,1,1,1,6)], period=5\r\n~~~\r\n\r\nExactly four continued fractions, for `N <= 13`, have an odd period.\r\n\r\nHow many continued fractions for `N <= 10000` have an odd period?", "v###\r\n #####\r\n0\r\n\">>1-:0\\951p11p021p131v      v12g14    p150 p13/g<\r\nI       vp01g03_v#-g01:_v#- <>g+31g/ :31g*21g-21v1\r\ni   @   >:30p:20 g\\/+2/: 30g^^12p14:<>11g21g:*-3 ^\r\n *  .           >    #$ >$30g::*11g-||+g15-1g13p<\r\n\"+  $   ^p02:p010g11p1<       v\\+1\\<>>0>\\#+ #1:#$_v\r\n>^^_^#-2:                     <   _^#          %2$<", "For this I had to re-use my old [integer-squareroot](https://en.wikipedia.org/wiki/Integer_square_root) implementation \r\nand I ported an [algorithm](http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cfINTRO.html#section7) for calculating the continued fraction to befunge.\r\n\r\nThe rest is just iterating through all the values and trying to optimize for speed.\r\n\r\nHere two useful snippets I made while solving this puzzle:\r\n\r\n - Calculating the **sum** of an zero-terminated array on the stack:   `>\\# :#+_+`\r\n - Calculating the **count** of an zero-terminated array on the stack: `0>\\#+ #1:#$_$`", 0, 24936143, 5804, 51, 9, 1322);
	Do(65, "Convergents of e", "The infinite continued fraction can be written, `sqrt(2) = [1;(2)]`, `(2)` indicates that `2` repeats ad infinitum.\r\nIn a similar way, `sqrt(23) = [4;(1,3,1,8)]`.\r\n\r\nIt turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations.\r\nLet us consider the convergents for `sqrt(2)`.\r\n\r\n~~~\r\n1 + 1/2                      = 3/2\r\n1 + 1/(2+ 1/2)               = 7/5\r\n1 + 1/(2+ 1/(2+ 1/2))        = 17/12\r\n1 + 1/(2+ 1/(2+ 1/(2+ 1/2))) = 41/29\r\n~~~\r\n\r\nHence the sequence of the first ten convergents for `sqrt(2)` are:\r\n~~~\r\n1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ...\r\n~~~\r\n\r\nWhat is most surprising is that the important mathematical constant,\r\n\r\n~~~\r\ne = [2; 1,2,1, 1,4,1, 1,6,1 , ... , 1,2k,1, ...]\r\n~~~\r\n\r\nThe first ten terms in the sequence of convergents for `e` are:\r\n~~~\r\n2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...\r\n~~~\r\n\r\nThe sum of digits in the numerator of the 10th convergent is `1+4+5+7=17`.\r\n\r\nFind the sum of digits in the numerator of the 100th convergent of the continued fraction for `e`.", "v $$$    #######################################################################\r\n\r\n         #######################################################################\r\n\r\n    v                 -1<\r\n>\"F\">:9+\"0\"\\0p:9+\"0\"\\2p:|\r\nv\"c\"p040p2\"O1\"p0\"O0\"   $<\r\n          >$1         v@.<v02-\"0\"p0g03:g2g03-\"0\"g0:p03:<-1<\r\n  >:1-3%:!|   >:1+3/2*v  +>g*+40g+:55+%\"0\"+30g2p55+/40p:9-|\r\n>:|       >2-#^_1     >20 p                      \"O\"v  #  $\r\n| ># #+ #1 #: #- #12# ^#                            ># ^# <\r\n$               >\\v  >\\:!|\r\n>0\"F\">:9+2g\"0\"-:| >:!|1 +<\r\n     ^        -1_ ^#1<", "Nice algorithm if you see the pattern in the numerators and denominators.\r\n\r\n~~~\r\ndenom(n+1) = denom(n) + numer(n) * frac(n)\r\nnumer(n+1) = denom(n)\r\n~~~\r\n\r\nand the fraction at position n is calculated by ([OEIS-A003417](https://oeis.org/A003417)):\r\n\r\n~~~\r\nint GetFrac(int idx)\r\n{\r\n	if (idx == 0) return 2;\r\n	if ((idx-1) % 3 == 0) return 1;\r\n	if ((idx-1) % 3 == 1) return ((idx+1)/3)*2;\r\n	if ((idx-1) % 3 == 2) return 1;\r\n	return 2;\r\n}\r\n~~~\r\n\r\nThe rest is just multiplication and long addition (we exceed the 64bit range) a hundred times ...", 0, 477489, 124, 80, 14, 272);
	Do(66, "Diophantine equation", "Consider quadratic Diophantine equations of the form:\r\n\r\n~~~\r\nx^2 – Dy^2 = 1\r\n~~~\r\n\r\nFor example, when `D=13`, the minimal solution in `x` is `649^2 – 13×180^2 = 1`.\r\n\r\nIt can be assumed that there are no solutions in positive integers when D is square.\r\n\r\nBy finding minimal solutions in `x` for `D = {2, 3, 5, 6, 7}`, we obtain the following:\r\n\r\n~~~\r\n3^2 – 2×2^2 = 1\r\n2^2 – 3×1^2 = 1\r\n9^2 – 5×4^2 = 1\r\n5^2 – 6×2^2 = 1\r\n8^2 – 7×3^2 = 1\r\n~~~\r\n\r\nHence, by considering minimal solutions in `x` for `D <= 7`, the largest `x` is obtained when `D=5`.\r\n\r\nFind the value of `D <= 1000` in minimal solutions of `x` for which the largest value of `x` is obtained.", "vYYY     ################\r\n XBXX    ################\r\n ZZZ     ################\r\n N\r\n OOO     ################\r\n         ################\r\n         ################\r\n         ################                           v 9::p4+9\\g5+9::p1+9\\g2+9: <\r\n         ################                           >+6g\\9+5p:1-\\!v0  <\r\n         ################                               v        $_::9+1g\\9+0p:^\r\n                                 v  _v#-*\"}\"8p13:+1g13$<              #     <\r\n>\"@ \":*:**21p331p013p88 +>:8+0\\8v    >11g.@   >+8p:1-\\!|  >-22g/22p35*^\r\nv         p02:p010g13<$<_^#!:-1p<             ^9\\g2+9::<# ^*:g21g13p21-g21*g 22<\r\nvp01g03_v#-g01:_v#- <^           <v_v#!:-1p0\\0+8:p1\\0 <^*53p11g13$_         ^  g\r\n>:30p:20 g\\/+2/: 30g^          >88 +>:8+0\\5p:8+0\\4p:8+^    >     `^      >$$ $v2\r\n        >       >$30g:41p:*31g-|  >$164*1p164*4p012p122pv  0 >$1+:9-8-     !| 03\r\n^p02:p010g13p13+1g13           <v       ># 3# 5# *#    #<v ^_^#:-g8+9\\g2+9::< <$\r\nv*53p23/g22+g21g14              <       $                                   >  ^\r\n>:::9+0g\\9+1g32g*+13g+:v v 53<          |!\\-1:g42$<      >::9+7g\\9+9g-      |\r\n|\\-1:p2+9\\%g12 p31/g12 < # >$     014p35 *>:9+0\\ v|!-9g43-1p7g43%g12p41/g12 :+g<\r\n>$35*:::9+4g\\9+5g32g*+13g+v  $        >*>2 4p35*  >::24g+# 6-34p9+2g24g9+2gv>1v7\r\n>:::9+4g\\9+5g32g*+13g+v   <|!\\-1:g42$<    |\\-1:p7<       ^               #  < -g\r\n|\\-1:p6+9\\%g12p31/g12:<>     # :9+0\\v| !-9 g43-1p9g43%g12p41/g12:+g9g43<v1*<|\\<4\r\n>$114p35*              ^ >*>2 4p35*#9> ::2 4g+6-34p9+6g24g9+6g31g**14g+^> 4g +3^\r\n                       ^    _^#\\-1:p< ^53$<                              ^ $<", "Okay I admit this one took me five days to complete (with two days pause in between, because of I kinda got frustrated).\r\n\r\nI needed eight numbers that were too big for int64 so I encoded them in base-67108864 (`2^26`).\r\nThe reason for this specific number (and I had to fail first to see the problem with bigger bases) is that the biggest calculation I do is `D_0 * D_0 * D * 1`.\r\nWhich is maximally `2^26 * 2^26 * 2^10` which fits *barely* in an signed 64-bit integer.\r\n\r\nAlso I needed to first write code to multiply two numbers, both in base-67108864 and both bigger than `2^63`. Let me tell you that was no fun and long-addition is far easier to implement than long-multiplication.\r\nEspecially after first I did everything wrong and then had to redo it :/\r\n\r\nThe first running version of this program was full of debug statements (even more than normally) and had a size of 200x60. (You can look at it, it\'s the `Problem-066 (annotated)` file).\r\nBut after that I managed to shrink it quite a bit :D I even *(barely)* managed to fit it in the 80x25 restriction.\r\nI have the feeling I\'ve gotten pretty good at compacting my programs...\r\n\r\nBut back to the interesting stuff, how did I solve this one:\r\n\r\nI can\' really explain everything in detail here, so I give you a few useful links:\r\n\r\n - [https://en.wikipedia.org/wiki/Diophantine_equation](https://en.wikipedia.org/wiki/Diophantine_equation)\r\n - [https://en.wikipedia.org/wiki/Pell\'s_equation](https://en.wikipedia.org/wiki/Pell%27s_equation)\r\n - [https://en.wikipedia.org/wiki/Generalized_continued_fraction](https://en.wikipedia.org/wiki/Generalized_continued_fraction)\r\n - [http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cfINTRO.html#section9.4](http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cfINTRO.html#section9.4)\r\n\r\nIf you want to have the `(x|y)` solution for a number D:\r\n\r\n - First you calculate the continuous fraction of `sqrt(D)`\r\n - For the continuous fraction you calculate the convergents `hi / ki` (read the link about Pell\'s equation)\r\n - Now you just test if `hi` and `ki` are solutions, if not go on to the next convergent pair\r\n\r\nIn the end the algorithm is really not that complex (around 30 lines in C#) but all the numbers get so big - and you need to multiply and add the already big numbers together so you get even bigger immediate values.\r\nSo on a last note I could say ... I wished the numbers in befunge were unlimited.", 0, 262481767, 55831, 80, 25, 661);
	Do(67, "Maximum path sum II", "By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.\r\n\r\n~~~\r\n3\r\n7 4\r\n2 4 6\r\n8 5 9 3\r\n~~~\r\n\r\nThat is, 3 + 7 + 4 + 9 = 23.\r\n\r\nFind the maximum total from top to bottom in [triangle.txt](https://projecteuler.net/project/resources/p067_triangle.txt) (right click and \'Save Link/Target As...\'), a 15K text file containing a triangle with one-hundred rows.\r\n\r\n*NOTE: This is a much more difficult version of [Problem 18]. It is not possible to try every route to solve this problem, as there are 299 altogether! If you could check one trillion (1012) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it. ;o)*", "$$>\"d\" 00p00g1-20p010p>10g3*:20g1+g\"0\"-55+*\\1+20g1+g\"0\"-+10g20g1+p10g1+:10p20g-1-#v_20g:1-20p010p#v_v\r\n59                    ^                                                           <               < v\r\n73 41                 v                                                                             <\r\n52 40 09                                                                           > $v\r\n26 53 06 34           >00g2-:10p  20p > 10g20g1+g  10g20g2+g  :  10g1+20g2+g -:0`>#^_-> + 10g20g1+ p   10g:1-10p#v_20g:1-:20p10p#v_  01g.@\r\n10 51 87 86 81                        ^                                                                          <               <\r\n61 95 66 57 25 68\r\n90 81 80 38 92 67 73\r\n30 28 51 76 81 18 75 44\r\n84 14 95 87 62 81 17 78 58\r\n\r\n... ... ...", "see [Problem-018]", 1, 650537, 266, 299, 101, 7273);
	Do(68, "Magic 5-gon ring", "Consider the following \"magic\" 3-gon ring, filled with the numbers 1 to 6, and each line adding to nine.\r\n\r\n![](https://projecteuler.net/project/images/p068_1.gif)\r\n\r\nWorking clockwise, and starting from the group of three with the numerically lowest external node (4,3,2 in this example), each solution can be described uniquely.\r\nFor example, the above solution can be described by the set: `4,3,2; 6,2,1; 5,1,3`.\r\n\r\nIt is possible to complete the ring with four different totals: 9, 10, 11, and 12. There are eight solutions in total.\r\n\r\nTotal |      Solution Set\r\n------|------------------------\r\n9     |  `4,2,3; 5,3,1; 6,1,2`\r\n9     |  `4,3,2; 6,2,1; 5,1,3`\r\n10    |  `2,3,5; 4,5,1; 6,1,3`\r\n10    |  `2,5,3; 6,3,1; 4,1,5`\r\n11    |  `1,4,6; 3,6,2; 5,2,4`\r\n11    |  `1,6,4; 5,4,2; 3,2,6`\r\n12    |  `1,5,6; 2,6,4; 3,4,5`\r\n12    |  `1,6,5; 3,5,4; 2,4,6`\r\n\r\nBy concatenating each group it is possible to form 9-digit strings; the maximum string for a 3-gon ring is `432621513`.\r\n\r\nUsing the numbers 1 to 10, and depending on arrangements, it is possible to form 16- and 17-digit strings.\r\nWhat is the maximum 16-digit string for a \"magic\" 5-gon ring?\r\n\r\n![](https://projecteuler.net/project/images/p068_2.gif)", "v  X   X ##########\r\n     X   OOOOOOOOOO\r\n>\":\"v   v                           < <\r\nv   <   vp1+9-\"0\"g0+9p03:-1g03\"O\"    <\r\n>90p030p>30g9+0g1-:30g9+0p\"0\"-:70p0\\`|\r\nv   g03_^#!         -\"O\"g1+9g07     #<$\r\n>:#v_70g5`                           >|\r\nv-1< v  _v#!`g039$                    <\r\n>:#v_     70g9-!                     ^\r\nv-1<     >\"X\"70g9+1p\":\"30g1+:30p9+0p^\r\n>:#v_ 90+0g91+0g92+0g++51p70g9-!     ^\r\nv-1< >91+0g\"/\"- 98+0g\"/\"- 99+0g\"/\"- v\r\n>:#v_90g\"0\"-70g`                     ^\r\nv-1< v-\"/\"g0+79 -\"/\"g0+69 -\"/\"g0+89 <\r\n>:#v_ 92+0g93+0g94+0g++51g-!!70g9-!+ ^\r\nv-1< >96+0g\"/\"- 94+0g\"/\"- 95+0g\"/\"- v\r\n>:#v_90g\"0\"-70g`                     ^\r\nv-1< v-\"/\"g0+39 -\"/\"g0+29 -\"/\"g0+49 <\r\n>:#v_ 94+0g95+0g96+0g++51g-!!70g9-!+ ^\r\nv-1< >92+0g\"/\"- 91+0g\"/\"- 90+0g\"/\"- v\r\n>:#v_90g\"0\"-70g`                     ^\r\nv-1<           @ ... ... ... ... ...<\r\n>:#v_96+0g97+0g98+0g++51g-!!70g9-!+  ^\r\nv89<\r\n>+0g99+0g91+0g++51g-!!90g\"0\"-70g`!!+ ^", "The solution to this problem is similar to problem-043.\r\nWe iterate through all possible 10-digit combinations but abort most paths pretty early through a few rules.\r\nThis leads to a pretty quick execution time an a not so big program.\r\n\r\nI even managed to squeeze all in only half the available width so the other half has space enough for an ASCII representation of the magic 5-gon ring :D.\r\n*(You can see the result in the `problem-068 (visual)` file)*\r\n\r\nThe main piece (excluding the act of pressing everything in such a small space) was formulating the rules.\r\nThe more (an the earlier triggering) rules, the less paths we have to traverse and the faster our program gets:\r\n*(I needed to index the elements of the ring, so I went clockwise from the outermost to the inner elements.*\r\n\r\nThe rules are:\r\n - `N_3 > N_0`, `N_5 > N_0`, `N_7 > N_0`, `N_9 > N_0`. We want `N_0` to be the smallest element to avoid getting the same solution multiple times, only rotated. (Also it is stated that we start counting from the smallest outer element)\r\n - `N_0 <= 5`, otherwise it can\'t be the smallest outer element\r\n - `N_1 <> 9`, `N_2 <> 9`, `N_4 <> 9`, `N_6 <> 9`, `N_8 <> 9`, otherwise we won\'t get an 16-digit number\r\n - `N_2+N_3+N_4 = N_0+N_1+N_2`, `N_4+N_5+N_6 = N_0+N_1+N_2`, `N_6+N_7+N_8 = N_0+N_1+N_2`, `N_8+N_9+N_1 = N_0+N_1+N_2`. Our condition for the ring to be \"magic\"", 0, 304112, 78, 39, 25, 6531031914842725);
	Do(69, "Totient maximum", "Euler\'s Totient function, `phi(n)` (sometimes called the phi function), \r\nis used to determine the number of numbers less than n which are relatively prime to n. \r\nFor example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, `phi(9)=6`.\r\n\r\nn  | Relatively Prime | phi(n) | n/phi(n)\r\n---|------------------|--------|-------\r\n2  | 1                | 1      |  2\r\n3  | 1,2              | 2      |  1.5\r\n4  | 1,3              | 2      |  2\r\n5  | 1,2,3,4          | 4      |  1.25\r\n6  | 1,5              | 2      |  3\r\n7  | 1,2,3,4,5,6      | 6      |  1.1666...\r\n8  | 1,3,5,7          | 4      |  2  \r\n9  | 1,2,4,5,7,8      | 6      |  1.5\r\n10 | 1,3,7,9          | 4      |  2.5\r\n\r\nIt can be seen that n=6 produces a maximum `n/phi(n)` for `n <= 10`.\r\n\r\nFind the value of `n <= 1,000,000` for which `n/phi(n)` is a maximum.", "v000000    // Project Euler - Problem 69\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\nv                     >p50g1+50pv                                         @.g07<\r\nv                     ^1g0<     >30g1+:30p40g-       #v_\"}}@\"**60p   0>:1g70g*v$\r\n>170p\"P\":10p3:20p*40p230pv^5g03_^#-\" \"g+1/g01\\%g01:g03<p050p030<      ^+1<v06:<$\r\nvp08*8**::**::8p11p10:\" \"<                                    _^#`g03g04< >g`  |\r\n>\"X\"30g:10g%\\10g/1+p30g>30g+:40g\\`       #v_$>30g1+:30p:10g%\\10g/1+g\" \"-|^  p07<\r\n                       ^p+1/g01\\%g01:\\\" \":<  ^                          <", "I had a really complicated solution where I tried to generate an Phi Sieve and had to work around a lot of corner cases.\r\nThen I looked at [this](http://www.mathblog.dk/project-euler-69-find-the-value-of-n-%E2%89%A4-1000000-for-which-n%CF%86n-is-a-maximum/) solution and - well - it\'s faster and simpler than mine.\r\nSo I translated it to befunge.", 0, 35542, 16, 80, 10, 510510);
	Do(70, "Totient permutation", "Euler\'s Totient function, `phi(n)` [sometimes called the phi function], \r\nis used to determine the number of positive numbers less than or equal to n which are relatively prime to n. \r\nFor example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, `phi(9)=6`.\r\n\r\nThe number 1 is considered to be relatively prime to every positive number, so `phi(1)=1`.\r\n\r\nInterestingly, `phi(87109)=79180`, and it can be seen that `87109` is a permutation of `79180`.\r\n\r\nFind the value of `n`, `1 < n < 10^7`, for which `phi(n)` is a permutation of n and the ratio `n/phi(n)` produces a minimum.", "v00000 000 // Project Euler - Problem 70\r\n ccc\r\n ?? ?? ??\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n                                                                           \r\n>55*6*:10p57*:20p*40p230p\"2(\"*11p\"}(\"*21p022p112p\"}22 \"***31p1v>030p     v>g   0\\v   v\\-1 < >g   0\\v   v\\-1 <\r\nvp08*8**::**::8p31p30:\" \"                                     _^#`g03g04< 2 v+55:<>\\1>9*\\:| 2 v+55:<>\\1>9*\\:|\r\n>\"X\"30g:10g%\\10g/3+p30g>30g+:40g\\`       #v_$>30g1+:30p:10g%\\10g/3+g\" \"-| 7 >%\\:#^|#/+55\\$< 8 >%\\:#^|#/+55\\$< \r\n                       ^p+3/g01\\%g01:\\\" \":<  ^                          <  >$ #\\>#<>\\# :#+_+^>$ #\\>#<>\\# :#+_vv\r\nvg11                                                                     <^                            < v -+<-\r\n>:42p::10g%\\10g/3+g\"X\"-#v_:1+>:52p::10g%\\10g/3+g\"X\"-#v_42g52g*:72p31g`#v_72g22g*42g1-52g1-*:82p12g*`#v_^v_v\r\n  >$12g.@                   v $<                                       <                     v       <  <\r\n^_^#-g12:+1             <   <^_^#-g12:+1             <                                       <p22g28p21g27<", "The solution is practically identical to the one from [Mathblog](http://www.mathblog.dk/project-euler-70-investigate-values-of-n-for-which-%CF%86n-is-a-permutation-of-n/).\r\nBut Kristian explains it much better than I :).\r\n\r\nWe use our trustworthy [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) snippet and the *GetCombinatoricHash*-function from problem-62\r\n\r\nThe rest was straight-forward and not really that interesting. ", 1, 29380799, 3713, 150, 47, 8319823);
	Do(71, "Ordered fractions", "Consider the fraction, `n/d`, where `n` and `d` are positive integers. If `n<d` and `HCF(n,d)=1`, \r\nit is called a reduced proper fraction.\r\nIf we list the set of reduced proper fractions for `d <= 8` in ascending order of size, we get:\r\n\r\n~~~\r\n1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8\r\n~~~\r\n\r\nIt can be seen that `2/5` is the fraction immediately to the left of `3/7`.\r\n\r\nBy listing the set of reduced proper fractions for `d <= 1,000,000` in ascending order of size, \r\nfind the numerator of the fraction immediately to the left of `3/7`.", "v X X C\r\n  X X ????\r\n\r\n>020p040p121p141p\"}}@\"**60pv\r\nv0                         <         >01+*v\r\n>1+ :3*7%!#v_:61p:3*7/:71p7*61g3*-:0`|    >81p61g7*91p41g91g*21g81g*`#v_v\r\n|-g06:     <                        <>01-*^v  p04g16p02g17p12g19p14g18<\r\n>$20g.\"/ \",,55+,40g.@               ^      <                            <", "For every denominator from `1` to `1 000 000` we generate a possible fraction where the numerator is `(d * 3) / 7`.\r\n(Every other fraction is either greater than `3/7` or has a greater difference than the generated).\r\n\r\nNow everything thats left is finding the fraction with the smallest difference to `3/7`.\r\n\r\nThe difference of two fractions is calculated (without floating points) by:\r\n\r\n~~~\r\nn1/d1 - n2/d2  ==  (n1*d2 - n2*d1)/(d1*d2)\r\n~~~\r\n\r\nThe rest is just iterating through all the possible fractions and in each step remembering the current best.\r\n\r\nWe don\'t even need to reduce the result to get a *proper* fraction. \r\nIf it could be reduced we would have got the reduced version first.\r\n(Because it has an smaller denominator).", 0, 77428679, 11981, 73, 8, 428570);
	Do(72, "Counting fractions", "Consider the fraction, `n/d`, where `n` and `d` are positive integers.\r\nIf `n<d` and `HCF(n,d)=1`, it is called a reduced proper fraction.\r\n\r\nIf we list the set of reduced proper fractions for `d <= 8` in ascending order of size, we get:\r\n\r\n~~~\r\n1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8\r\n~~~\r\n\r\nIt can be seen that there are 21 elements in this set.\r\n\r\nHow many elements would be contained in the set of reduced proper fractions for `d <= 1,000,000`?", "v00000     // Project Euler - Problem 72\r\n XX     |AAAAAAAAAAAAAAAAAAA|\r\n OOOO\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>699**:10p3777***:20p*40p230p\" \":03p13p\"}}@\"**11p192*+21p022pv >030p0>::10g%\\10g/3+g\"X\"-#v_v\r\nvp+3/g01\\%g01:\\\"#\":-1<g04                            p242p231<            v%g01:p03+1:g03 :<\r\n>                   :|                                               ^   <>\\10g/3+pv\r\nv                   $<0                                       _^#`g03g04<|-g04:+1  <     <\r\n>\"X\"30g:10g%\\10g/3+p30g>30g+:40g\\`       #v_$>30g1+:30p:10g%\\10g/3+g\" \"-|$\r\n  >              v     ^p+3/g01\\%g01:\\\" \":<  ^                          <\r\nv_^#!:p1+9\\\" \":-1<g12                                 p21/2-\\*::g11p05g03<\r\n>$091pv          v                                     p23*g23-1p24*<\r\nv     <          <p23*g23p24*g24:g+3/g01\\%g01:p1+9g22:g1+9p22+1:g22<^g24:g+3/g01\\%g01:g1+9g22<\r\n>42g11g`#v_32g12g42g1--+12p>21g1-22g`22g9+1g:10g%\\10g/3+g42g*11g`!*|>9+1g:10g%\\10g/3+g*11g`!*|\r\n         >                 ^vg01:g1+9g22p24/g+3/g01\\%g01:g1+9g22g24<^g22g24`g1+9g22g05<v22\" \"<\r\n                            >%\\10g/3+g22g0`22g9+1g22g8+1g-!*!-32g\\/32p22g9+1g1+22g9+1p^g\r\n                  >*!-32g\\/32p22g9+1g1+22g9+1p        #@ #. #g #2 #1 #<               ^9\r\n                  ^!-g1+8g22g1+9g22`0g22p24/\\g24:g+3/g01\\%g01:g1+9g22_^#!`p22:-1g220p1+<", "First we need the number of proper reduced fractions for a denominator `d`.\r\nThis is the amount of numbers `d<n` with `gcd(d,n) == 1`.\r\nCoincidentally this is again Eulers Phi-Function.\r\n\r\nNow we need to find the sum over all phi values from `1` to `1 000 000`.\r\n\r\nFirst we get all the prime numbers from `2` to `limit/2` (with an [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)).\r\nThen we iterate through all possible prime combinations smaller than the limit (practically this is prime factorization).\r\nWhile we do this we calculate on the side the phi value of these numbers (with the prime factorization this is trivial) and sum these values together.\r\n\r\nFor all values bigger than `LIMIT/2` where we haven\'t got a factorization we use `phi(p) = p-1`.\r\nBecause these *must* be prime. *(see [Eulers totient function](https://en.wikipedia.org/wiki/Euler\'s_totient_function))*\r\n\r\nThe rest is a bit of clever optimization, so this all does not take too long.\r\n\r\n - First we assume every number is prime and calculate the sum of the phi function of all these primes.\r\n   Then when we find a number (that is not a prime) we subtract the old (wrong) value from the result and add the new (correct) value.\r\n - We abort our loops early when we run into a number `x > limit`. Because every other factor will only increase `x`.\r\n - The value of phi is always calculated from the last phi value. So we don\'t need to totally recalculate it in every step.\r\n\r\nAfter looking a little bit around this is not ***the** fastest solution to this problem.\r\nBut it\'s the one I found and I think it\'s reasonable fast.", 1, 339636085, 50606, 486, 1047, 303963552391);
	Do(73, "Counting fractions in a range", "Consider the fraction, `n/d`, where n and d are positive integers. If `n<d` and `HCF(n,d)=1`, it is called a reduced proper fraction.\r\n\r\nIf we list the set of reduced proper fractions for `d <= 8` in ascending order of size, we get:\r\n\r\n~~~\r\n1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8\r\n~~~\r\n\r\nIt can be seen that there are 3 fractions between `1/3` and `1/2`.\r\n\r\nHow many fractions lie between `1/3` and `1/2` in the sorted set of reduced proper fractions for `d <= 12,000`?", "v          // Project Euler - Problem 73\r\n XX  ????\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>\"}`\"*11p051p0v\r\nvp12*\"(2\"     <     v+1                    <                 <\r\n>1+:1+2/61p:71p:3/1+>:61g\\`!#v_:21g%71g3+g!|>81g11g`91g11g`+#^_081g21gv\r\n|-g11:                  >#$ #<              ^p19+g19g17p18+g18:p+3g19%<\r\n>$51g.@                 ^p19g17p18:p15+1g15<", "Here we brute-force through every possible denominator `d` (from 1 to 12000).\r\nFor every denominator the valid numerators are between `floor(d/3)` and `ceil(d/2)`.\r\n\r\nThe only problem is that we don\'t know if a fraction is proper.\r\nTo solve this we use a `12000x12000` array where we mark the already found fractions and every multiple of them.\r\nWhen we now find a new one we can test if we have already found the fraction (in a reduced form).\r\n\r\nBut a `12000x12000` array is *quite* big, the resulting b93-file was 140MB big.\r\nBut we know that most of the array will never be accessed,\r\nonly the columns between `d/3` and `d/2` are important and the biggest range is in the last row (`LIMIT/3 - LIMIT/2`).\r\nSo in each array-acess we modulo the x coordinate by `LIMIT/3 - LIMIT/2` (= `2000`).\r\nNow our array has only a size of `12000x2000` and the befunge-file is *only* 23MB big.\r\n\r\nThe program is not that fast, but that\'s mostly because of it\'s raw size, the algorithm is quite good (`200ms` when I implement it in C#)", 1, 1281174401, 202458, 2000, 12010, 7295372);
	Do(74, "Digit factorial chains", "The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:\r\n\r\n~~~\r\n1! + 4! + 5! = 1 + 24 + 120 = 145\r\n~~~\r\n\r\nPerhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169;\r\nit turns out that there are only three such loops that exist:\r\n\r\n~~~\r\n169 -> 363601 -> 1454 -> 169\r\n871 -> 45361 -> 871\r\n872 -> 45362 -> 872\r\n~~~\r\n\r\nIt is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,\r\n\r\n~~~\r\n69 -> 363600 -> 1454 -> 169 -> 363601 (-> 1454)\r\n78 -> 45360 -> 871 -> 45361 (-> 871)\r\n540 -> 145 (-> 145)\r\n~~~\r\n\r\nStarting with 69 produces a chain of five non-repeating terms,\r\nbut the longest non-repeating chain with a starting number below one million is sixty terms.\r\n\r\nHow many chains, with a starting number below one million, contain exactly sixty non-repeating terms?", "v      X ##########            // Project Euler - Problem 74\r\n CCC\r\n XXXX   |------------------------------------------------------------|\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>98+8*9*11p\"+&\"*2/21p\"}}@\"**31p042p31g>1-:0\\:11g%v\r\nvg11:-8*:+\"W~\"2p+4/g11\\%g11:/3*\"\'C\"2p<|:p+4/g11\\ <       v   <\r\n%>8-:11g%\\11g/4+p3\",!\"*2+:11g%\\11g/4+^$      >:70g:1+70p9 +0v\r\n\\^**\"CCQ\"3p+4/g11\\%g11:+\"+~\"3p+4/g11\\<>070p11|-+55g07*g07  p<^          p22+g22_v\r\n>11g/4+p2\"m\"8*:11g%\\11g/4+ v         ^%g11:00<           # >:55+%9+0v>11g/4+g: ^$\r\nv1$p+4/g11\\%g11:-7*:+\"W~\"2p<>12g22g1+:22p9+2p32g1+32p12g0\\:|:/+55\\g <^\\%g11:g21<\r\n>:12p022p092p032p32g9+2g12g-|-g21g2+9g23                  <>$>\\# :#+_+:12p31g`!| \r\n v                          <                            <^                    <<\r\n+>22g\"<\"-#v_42g1+42p>1>:9+2g31g`#v_::22g1+\\-\\9+2v\r\n1 >$42g.@ >         ^ ^+1_v#-g23:<p+4/g11\\%g11:g<\r\n^_^#-g13:                $<", "The factorial part is pretty easy - we cache the factorials from 1 to 9 and then we can calculate `facdigitsum(n)` in `O(log_10(n))`.\r\n\r\nThe problemdescription tells us there are only seven numbers in a loop (`{169, 363601, 1454}`, `{871, 45361}`, `{872, 45362}`).\r\nSo every other chain ends with a number mapping to itself. We manually insert these seven numbers in our grid and calculate the rest (where we only need to test if `f(n) == f(n-1)`).\r\n\r\nAnd we cache ever calculated value of `chainlength()` in our 1000000-element array. So as soon as we reach an already calculated number we can stop.\r\nThis works because there are no loops (except the seven pre-inserted values) and every chain is strictly linear.\r\n\r\nBe sure to check out the pre-optimized version of this to see just how much more condensed this version is :)", 1, 376912541, 49187, 1224, 833, 402);
	Do(75, "Singular integer right triangles", "It turns out that 12 cm is the smallest length of wire\r\nthat can be bent to form an integer sided right angle triangle in exactly one way,\r\nbut there are many more examples.\r\n\r\n~~~\r\n12 cm: (3,4,5)\r\n24 cm: (6,8,10)\r\n30 cm: (5,12,13)\r\n36 cm: (9,12,15)\r\n40 cm: (8,15,17)\r\n48 cm: (12,16,20)\r\n~~~\r\n\r\nIn contrast, some lengths of wire, like 20 cm,\r\ncannot be bent to form an integer sided right angle triangle,\r\nand other lengths allow more than one solution to be found;\r\nfor example, using 120 cm it is possible to form exactly three different integer sided right angle triangles.\r\n\r\n~~~\r\n120 cm: (30,40,50), (20,48,52), (24,45,51)\r\n~~~\r\n\r\nGiven that L is the length of the wire, \r\nfor how many values of `L <= 1,500,000` can exactly one integer sided right angle triangle be formed?", "v XX  O OO // Project Euler - Problem 75\r\n  AAA A A\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n\r\n> \"}\"8* 20p  \"}}`\"** 30p     30g>:0\\:20g%\\20v\r\nv                         p060$_^#!\\-1:p+3/g<\r\n     v                                          p08+1g08<\r\n>180p>80g::*4*\\6*2++30g`#v_>80g1+:90p>::2**\\80g2**+30g` |\r\n                    @.g06<           ^p09:+1g09<\r\nv g13g12p16++p14:+*:g08*:g09p13:**2g09g08p12:-*:g08*:g09<\r\n>`#v_           >1>:61g*30g`#v_:21g7*31g+5*41g+# *81p:61g*:20g%\\20g/3+g:#v_v\r\n   >21g31g21p31p^ ^+1       <># $#             ^#         _v#<`\\0_v#-g18:<  \r\n                            ^p06-1g06p+3/g02\\%g02:\\-10*g16:<v1#            <\r\n                            ^p06+1g06p+3/g02\\%g02:\\g18*g16:$<^   $<", "Luckily there is a simple formula to generate [Pythagorean triples](http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple).\r\n\r\n~~~\r\na = k * (m*m - n*n);\r\nb = k * (2*m*n);\r\nc = k * (m*m + n*n);\r\n~~~\r\n\r\nWe have a cache of the size `1500001` the we go through all the values for `m` and `n` where `2*m*m + 2*m*n <= LIMIT`.\r\n\r\nWhen we have found a triple we look in the cache at position `a+b+c`:\r\n - If the value is not set (0) we write the the triple-hash (`(a*7 + b)*5 + c`) at the position and increment the result.\r\n - If there is already an hash that equals with our current triple we do nothing\r\n - If there is already an different hash we write `-1` in the cache and decrement the result.\r\n - If there is an `-1` in the cache we do nothing\r\n\r\nSo at the end we have the amount of sum\'s with exactly one solution in our result-value.\r\n\r\nWe have to test for equal hashes because its possible to find the same tuple multiple times (with different `k` values).", 1, 293080647, 39951, 1000, 1515, 161667);
	Do(76, "Counting summations", "It is possible to write five as a sum in exactly six different ways:\r\n\r\n~~~\r\n4 + 1\r\n3 + 2\r\n3 + 1 + 1\r\n2 + 2 + 1\r\n2 + 1 + 1 + 1\r\n1 + 1 + 1 + 1 + 1\r\n~~~\r\n\r\nHow many different ways can one hundred be written as a sum of at least two positive integers?", "v  X OO    // Project Euler - Problem 76\r\nv\r\nv\r\n   + ... +\r\n   . . . .\r\n   .  .  .\r\n   . . . .\r\n   + ... +\r\n\r\n        v+1           p:+3\\+1g06:$<            > :50g\\-3v\r\n>\"d\"30p1>:30g`#v_:50p060p1>:50g-!#^_::::50g\\-`#^_:     3v\r\n               >1+:1+g.@  ^+1p+3g05+3\\p06:+g06g+3-\\g05\\+<", "The big trick is - similar to many other problems - *caching*.\r\n\r\nThis problem remembered me a little bit of problem-15.\r\nWe use a `100x100` grid to remember pre-calculated sums.\r\n\r\nSo in cell [3, 6] is the amount of sums which result in `6`, start with `3` and have all summands in descending order:\r\n\r\n~~~\r\n3 + 3\r\n3 + 2 + 1\r\n3 + 1 + 1\r\n~~~\r\n\r\nYou see `cache[3,6] = 3`.\r\n\r\nNow to find a new value (for example `[4, 7]`) we just have to look at the our cache:\r\n\r\n~~~\r\n7 = 4 + x\r\nsum(x) = 7-4 = 3\r\n\r\n// first_digit_of_x <= first_digit, because of the descending order\r\nsum(x) = sum([n, 3]); n = [1..3]\r\nsum(x) = [3, 3] + [2, 3] + [1, 3] \r\n~~~\r\n\r\nYou see it\'s important not only to remember the amount but also the first (= highest) summand, \r\nso we can guarantee the oder of the sums (an this way that we don\'t count any sums multiple times).\r\n\r\n*Note:* `cache[a, a]` is always `1`. But the problem rules dictate that when we calculate the final result we must ignore this (`100 = 100` is not a valid solution)\r\n\r\nOh and this algorithm improves the native approach (enumerating all solutions) from `O(wtf)` to `O(n^2)`.\r\nI\'m not sure if I would be still alive when my first algorithm finishes :)\r\n\r\n----\r\n\r\n**Edit:** \r\n\r\nI did a little optimization:\r\n\r\nThe value of cell `[d, s]` is now the sum of all previous cells from `[0, s]` to `[d, s]`.\r\n\r\nThis way we don\'t have to iterate through all the cells from 0 to d every time.\r\nWe can just look at the biggest cell which contains the sum of all previous.", 1, 296178, 32, 104, 108, 190569291);
	Do(77, "Prime summations", "It is possible to write ten as the sum of primes in exactly five different ways:\r\n\r\n~~~\r\n7 + 3\r\n5 + 5\r\n5 + 3 + 2\r\n3 + 3 + 2 + 2\r\n2 + 2 + 2 + 2 + 2\r\n~~~\r\n\r\nWhat is the first value which can be written as the sum of primes in over five thousand different ways?", "v00000 00  // Project Euler - Problem 77\r\n XXXXXX\r\n# ... #\r\n\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n> \"e\" :10p 1 :20p*40p230p\" \":02p12pvv03:+1g03<        >030p    0>::10g%\\10g/2+g\"X\"-#v_:30g:1+30p:v\r\nv                                  <># p# :#  v#     _^#`g03g04<|-g04:+1            <p+2/g01\\%g01<\r\n>\"X\"30g:10g%\\10g/2+p30g>30g+:40g\\`       #v_$^>10g%\\10g/2+g\" \"-|>$30g:50p10g*>1-:0\\:10g%\\10g/4+pv\r\n                       ^p+2/g01\\%g01:\\\" \":<  ^                 <             ^_v#:              <\r\nvp08\"d\"p07*\"}(\"$                                                               <\r\n0                                                   >061p31g>:0\\`#v_:4+51g\\g61g+61pv\r\n>1+:11p021p031p>31g:50g-\\2g:41p11g`!*!#v_11g41g-:51p|       ^-1                    <\r\n^                           _v#!`g07g12<            >111g31g4+pv  >$21g61g:1v\r\n               ^             ># 1# 1# g# .# @#         p13+1g13<p12+p+4g13g1<", "For an extended explanation please look at problem-076, it\'s basically the same..\r\n\r\nYet again we remember already calculated values in an grid.\r\nThe only difference is now that our y-axis is the prime index (We generate a few primes with an [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)).\r\n\r\nAnd once we find a number which count is greater five thousand we abort and print this number.\r\n\r\nThe only mayor difference to problem-076 is that now not every summand is valid.\r\nIt is possible that you can use `prime[7]` but not `prime[6]`.\r\nSo we have to look at each possible summand individually.\r\nThis makes unfortunately the optimization where we remember the sum of all values invalid.", 1, 312139, 47, 101, 39, 71);
	Do(78, "Coin partitions", "Let `p(n)` represent the number of different ways in which n coins can be separated into piles.\r\nFor example, five coins can be separated into piles in exactly seven different ways, so `p(5)=7`.\r\n\r\n~~~\r\nOOOOO\r\nOOOO   O\r\nOOO    OO\r\nOOO    O   O\r\nOO     OO  O\r\nOO     O   O  O\r\nO      O   O  O  O\r\n~~~\r\n\r\nFind the least value of n for which p(n) is divisible by one million.", "vXX OOO\r\n # ... #\r\n . . . .\r\n .  .  .\r\n . . . .\r\n # ... #\r\n\r\n                                              >$.@ \r\n                        v+1p+1/g01\\+1%g01:g04_^#:%g02g05$$              <\r\n>\"}}@\"**20p\"~|\"+10p111p1>:40p050p0>:60p::2/1+:*3*\\:2/1+\\2%2*1-*+2/:40g`#^_4 v\r\n                                  ^+1p05-\\g05*-1*2%2/2g06g+1/g01\\+1%g01:-\\g0<", "Again the algorithm is from [MathBlog](http://www.mathblog.dk/project-euler-78-coin-piles/).\r\nI can\'t really say that I understand the algorithm fully (and the MathBlog guy says he neither).\r\n\r\nBut for the best explanation you better read his article.", 1, 1191633332, 170946, 251, 256, 55374);
	Do(79, "Passcode derivation", "A common security method used for online banking is to ask the user for three random characters from a passcode.\r\nFor example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters;\r\nthe expected reply would be: 317.\r\n\r\nThe text file, keylog.txt, contains fifty successful login attempts.\r\n\r\n~~~\r\n319 680 180 690 129 620 762 689 762 318\r\n368 710 720 710 629 168 160 689 716 731\r\n736 729 316 729 729 710 769 290 719 680\r\n318 389 162 289 162 718 729 319 790 680\r\n890 362 319 760 316 729 380 319 728 716\r\n~~~\r\n\r\nGiven that the three characters are always asked for in order,\r\nanalyse the file so as to determine the shortest possible secret passcode of unknown length.", "v\r\n ++++++++++ 319 680 180 690 129 620 762 689 762 318\r\n ++++++++++ 368 710 720 710 629 168 160 689 716 731\r\n ++++++++++ 736 729 316 729 729 710 769 290 719 680\r\n ++++++++++ 318 389 162 289 162 718 729 319 790 680\r\n ++++++++++ 890 362 319 760 316 729 380 319 728 716\r\n ++++++++++\r\n ++++++++++ ##########\r\n ++++++++++\r\n ++++++++++ XXXXXXXXXX\r\n ++++++++++\r\n\r\n>55+>:1\\:v>:55+/1+30p:55+%4*66++20p020g0+30gg\"0\"-:50p66v\r\n    |:-1p< v1g070p+1g07+1g062p+1g07+1g052p+1g06+1g052< +\r\n    >$ 77*^>+50g1+p070g1+60g1vv<          <          p +\r\n          |\\-1:p+1g05+1g060p+<1|!\\-1:   <p 9++66 p0< 7 7\r\n        v+># $# 0# 9# 0# p# 9#<>:66++7g#^_ :90g:1+9^ + p\r\n        >:90g-!#v_:::66++9g1+\\65++9g1+g*!#^_::v      + 0\r\n        ^p9++66\\ g02:-1p9++66\\g9++56p02g9++66:<      6 2\r\n                >$0>:66++9g. v   >020g2+30gg\"0\"-:70p6^ 0\r\n                @$_^#!-g09:+1<   ^p7++66p06:-\"0\"gg03+1g<", "This is one of the problems i really enjoyed solving.\r\n\r\nWe make the assumption that our final pass code has no duplicate digits (If we hadn\'t found a solution we would need to change that part).\r\nThis is a pretty good assumption because no attempt has a duplicate digit in it.\r\n\r\n> *Side note:* This leaves us with a 8-digit code, because only 8 digits are used (`4` and `5` are missing).\r\n\r\nFirst we generate a 10x10 grid where we remember the absolute ordering of the numbers from our attempts (eg `3` is before `8` or `9` is after `2`).\r\nIf we inspect this data we can see that every field (for numbers in our pass code) is set, the fifty login attempts generate more than enough data for this.\r\n\r\n> *Side note:* In fact there are only 33 **unique** login attempts\r\n\r\nThen we can simply sort an array of the valid digits with this ordering. And - frankly - I find this is a really neat way of doing this.\r\n\r\nBecause we sort only eight numbers, sorting-performance is not a big factor.\r\nSo I searched for the simplest (easiest to implement) sorting algorithm I could find.\r\nThis was surprisingly not Bubble-sort, but [Gnome Sort](https://en.wikipedia.org/wiki/Gnome_sort) (accordingly to the author \"the simplest sort algorithm\").\r\nWhich was pretty easy to implement in Befunge (and for 8 values is the runtime of O(n^2) not *that* bad).\r\n\r\nA last thing: For a problem where I used an two-dimensional cache **and** that has input data I was surprised to fit everything in the Befunge-93 80x25 size restrictions.\r\n", 0, 12040, 0, 56, 21, 73162890);
	Do(80, "Square root digital expansion", "It is well known that if the square root of a natural number is not an integer, then it is irrational. \r\nThe decimal expansion of such square roots is infinite without any repeating pattern at all.\r\n\r\nThe square root of two is `1.41421356237309504880...`, \r\nand the digital sum of the first one hundred decimal digits is `475`.\r\n\r\nFor the first one hundred natural numbers, \r\nfind the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.", "v X X XX X\r\n         ############################################################\r\n\r\n @       ############################################################\r\n .\r\n g       ############################################################\r\n 0\r\n ^9$># #<         v             v               <   v    <\r\n    $ v_^#-\"d\"\\+1:<       <>$\"<\">1-::9+5g\\9+1p:#^_$0>:::9+3g55+%55+*v\r\n>090p2>:20p\"d\">::*20g-#v_$^|!:-1p5+8\\-g07g06p04          #         <\\\r\n    #  v\"<\":$_^#   !:-1<   >::9+1g40g-60p:9+3g20g45***70p0>70g60g`!|5\r\n    ^ <>1-:0\\9+1p:0\\v      ^         \";\"p04* :g02p5\"D\"0p<#+        65\r\n       |:p5+9\\0:p3+9< >9+1g-!#v_::9+5g\\9+1g`!#v_$20g1-20^ 1        0+\r\n       >$\"D\"1p\"d\"020p>20g:*40p \"<\">1-::9+3g20g 45***40gv  ^p06+\"d\"g<+\r\n      ^ _>         #v^#-\"<\":+1<   |:p5+9\\%\"d\"p 04/\"d\":+<v3+9\\+/+55g3<\r\n                   v_v^\\g5+9::<0 $<                v:+1p<#\r\n         ^p02+1g02$>#<#       ^#              <    > \";\"-|\r\n        ^       !:-1p020p09+g09g02p3\"D\"+g02*+55%+55g3\"D\"$<", "A short look to [Wikipedia](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation) finds us a neat algorithm to calculate the square-root digit-by-digit.\r\n\r\nI have optimized it a little bit with the target to use not so many variables:\r\n\r\n~~~\r\nIEnumerable<int> DRoot(int r)\r\n{\r\n	BigInteger c = r;\r\n	BigInteger p = 0;\r\n	int x = 0;\r\n\r\n	for (ii = 0; ii < 100; ii++)\r\n	{	\r\n		for (x = 0;(x+1)*(20*p + (x+1)) <= c;x++);\r\n		c = 100*c  - 2000*p*x - 100*x*x;\r\n		p = p*10 + x;\r\n	}\r\n	\r\n	return p;\r\n}\r\n~~~\r\n\r\nThe algorithm is pretty simple, but *god* do I hate long addition/multiplication in Befunge.\r\n\r\nWe need 120 base-10 digits for the numbers `p`and `c`.\r\nIn our program we use base-100 notation. This way we can fit the numbers in a single befunge-93 row \r\n**and** can simply multiply by 100 with a single left shift operation.", 0, 540417723, 116439, 69, 18, 40886);
	Do(81, "Path sum: two ways", "In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, \r\nby only moving to the right and down, is indicated in bold red and is equal to 2427.\r\n\r\n~~~\r\n131 673 234 103 018\r\n201 096 342 965 150\r\n630 803 746 422 111\r\n537 699 497 121 956\r\n805 732 524 037 331\r\n~~~\r\n\r\nFind the minimal path sum, in matrix.txt (right click and \"Save Link/Target As...\"), \r\na 31K text file containing a 80 by 80 matrix, \r\nfrom the top left to the bottom right by only moving right and down.", "v                       4445 2697 5115 ... 5870\r\n                        1096 0020 1318 ... 9377\r\n         # ... #        9607 7385 0521 ... 9230\r\n         . . . .        7206 3114 7760 ... 2187\r\n         .  .  .        3620 8024 0577 ... 7505\r\n         . . . .        1074 5438 9008 ... 6942\r\n         # ... #        4295 1176 5596 ... 4757\r\n\r\n>\"d@\"*>1-:::::\"P\"%5*\"g\"+\\\"P\"/g\"0\"-\\::\"P\"%5*\"f\"+\\\"P\"/g\"0\"-\\::\"P\"%5*\"e\"+\\\"P\"/g\"0\"-\\:  v\r\n      |:p+\"d\"/\"P\"\\+9%\"P\":\\*:*\"~~\"p+2/\"P\"\\+9%\"P\":\\+*+55+*+55+*+55-\"0\"g/\"P\"\\+\"d\"*5%\"P\"<\r\n      $                                                                              >20g8+30g\"d\"v\r\n      >0>:20p   0>:30p20g9+30g2+g20g9+30g\"c\"+g20g8+30g\"d\"+g20g30g+!#v_20g!#v_30g!#v_`|\r\n                 |-\"P\":+1p+\"d\"g03+9g02                           <      <     <     <>20g9+30g\"c\"v\r\n        |-\"P\":+1$<                                               ^$$<   ^+$<  ^+$\\< ^         +g+<\r\n        $\r\n        >\"O\"9+\"Od\"+g.@\r\n\r\n\r\n\r\n\r\n         # ... #\r\n         . . . .\r\n         .  .  .\r\n         . . . .\r\n         # ... #", "Well, this is practically extremely simple path finding.\r\n\r\nWe generate an array where we remember the shortest distance from [0,0] to this node.\r\nInitially we can set `distance[0, 0] = data[0,0]`\r\n\r\nThe we got through our data row by row and column by column.\r\nThe distance of every node we visit is the minimum of `top-node-distance + own value` and `left-node-distance + own value`.\r\n\r\nThen after we iterated through every single node the result is written in the bottom right corner.", 1, 1697244, 234, 500, 180, 427337);
	Do(82, "Path sum: three ways", "NOTE: This problem is a more challenging version of Problem 81.\r\n\r\nThe minimal path sum in the 5 by 5 matrix below,\r\nby starting in any cell in the left column and finishing in any cell in the right column,\r\nand only moving up, down, and right, is indicated in red and bold; the sum is equal to `994`.\r\n\r\n~~~\r\n131 673 234 103 018\r\n201 096 342 965 150\r\n630 803 746 422 111\r\n537 699 497 121 956\r\n805 732 524 037 331\r\n~~~\r\n\r\nFind the minimal path sum, in matrix.txt (right click and \"Save Link/Target As...\"), \r\na 31K text file containing a 80 by 80 matrix, \r\nfrom the left column to the right column.", "v                       4445 2697 5115 ... 5870\r\n                        1096 0020 1318 ... 9377\r\n         # ... #        9607 7385 0521 ... 9230\r\n         . . . .        7206 3114 7760 ... 2187\r\n         .  .  .        3620 8024 0577 ... 7505\r\n         . . . .        1074 5438 9008 ... 6942\r\n         # ... #        4295 1176 5596 ... 4757\r\n\r\n>\"d@\"*>1-:::::\"P\"%5*\"g\"+\\\"P\"/g\"0\"-\\::\"P\"%5*\"f\"+\\\"P\"/g\"0\"-\\::\"P\"%5*\"e\"+\\\"P\"/g\"0\"-\\:  v\r\n      |:p+\"d\"/\"P\"\\+9%\"P\":\\*:*\"~~\"p+2/\"P\"\\+9%\"P\":\\+*+55+*+55+*+55-\"0\"g/\"P\"\\+\"d\"*5%\"P\"<\r\n      $\r\n      >\"P\">1-::9\\2+gv\r\n          |:p+\"d\"\\9\\<                                                             >$$v                                                          >v\r\n          >$1>:20p0>:30p20g8+30g\"d\"+g40p30g>:50p40g20g9+50g2+g+::40p20g9+50g\"d\"+g`|  >20g8+30g\"d\"+g40p30g>:50p40g20g9+50g2+g+::40p20g9+50g\"d\"+g`| \r\n                   ^  <                    |-\"P\":+1                  p+\"d\"g05+9g02<  $                   |+1:-1                    p+\"d\"g05+9g02< \r\n                      |-\"P\":+1             >#                                        ^#                 $<$                                      <\r\n             |-\"P\":+1$<                            >70v\r\n             >$\"O\"9+\"Od\"+g70p\"O\">1-:\"X\"\\\"d\"+g:70g`!|\r\n                                |:                $<0p<\r\n                                >$70g.@\r\n\r\n\r\n         # ... #\r\n         . . . .\r\n         .  .  .\r\n         . . . .\r\n         # ... #", "As the problem description states this is similar to problem-081.\r\n\r\nAgain we generate an node-array where we remark the minimal distance from the left side to this node.\r\nInitially we can initialize the left column with its input values.\r\n(`distance[0, y] = data[0, y]`) and all the other nodes with an absurdly high number.\r\n\r\nThen we iterate through all remaining columns:  \r\n\r\nFor each column `x` we go all possible ways from the previous column. That means:\r\n - Choose the start-row `y` (and do this for all possible start rows)\r\n - Get the distance to reach this row by calculating `distance[x-1, y] + data[x, y]`\r\n - Then go all the way up and down and calculate the distance on the way `distance[x-1, y] + data[x, y] + data[x, y - 1] + data[x, y - 2] ...`\r\n - For each node where this distance is lesser than the current one we update distance array.\r\n - *Optimization node:* Once we find a node where the distance is greater than a previous calculated we can stop further traversing the column (in this direction)\r\n \r\nAt the end we have an distance array where each node is the minimal distance to reach this node from the left side.\r\nOur result is then the minimal value of the most-right column.\r\n\r\n*Note:* While problem-081 hat an time complexity of O(n) this one has one of O(n^2).\r\nBut for an 80x80 array that\'s still fast enough and really not an problem.", 1, 13777233, 2106, 500, 180, 260324);
	Do(83, "Path sum: four ways", "NOTE: This problem is a significantly more challenging version of Problem 81.\r\n\r\nIn the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, \r\nby moving left, right, up, and down, is indicated in bold red and is equal to `2297`.\r\n\r\n~~~\r\n131 673 234 103 018\r\n201 096 342 965 150\r\n630 803 746 422 111\r\n537 699 497 121 956\r\n805 732 524 037 331\r\n~~~\r\n\r\nFind the minimal path sum, in matrix.txt (right click and \"Save Link/Target As...\"), \r\na 31K text file containing a 80 by 80 matrix, \r\nfrom the left column to the right column.", "v                       4445 2697 5115 ... 5870\r\n                        1096 0020 1318 ... 9377\r\n         # ... #        9607 7385 0521 ... 9230\r\n         . . . .        7206 3114 7760 ... 2187\r\n         .  .  .        3620 8024 0577 ... 7505\r\n         . . . .        1074 5438 9008 ... 6942\r\n         # ... #        4295 1176 5596 ... 4757\r\n\r\n>\"d@\"*>1-:::::\"P\"%5*\"g\"+\\\"P\"/g\"0\"-\\::\"P\"%5*\"f\"+\\\"P\"/g\"0\"-\\::\"P\"%5*\"e\"+\\\"P\"/g\"0\"-\\:  v\r\n      |:p+\"d\"/\"P\"\\+9%\"P\":\\*:*\"~~\"p+2/\"P\"\\+9%\"P\":\\+*+55+*+55+*+55-\"0\"g/\"P\"\\+\"d\"*5%\"P\"<                                                   >70g40g8+50g\"d\"+p  v\r\n      >$120p92g9\"d\"p\"Xdd\"p>0>:40p   0>:50p40g\"d\"+50g\"d\"+g\"X\"-#v_820p\"O\"40g\"d\"+50g\"d\"+p 40g0`40g8+50g\"d\"+g40g9+50g\"d\"+g40g8+50g2+g+:70p`*|\r\n                                     |-\"P\":+1                 <                       v                                                 <p+\"d\"g05+\"c\"g04\"X\"<\r\n                    >     ^ |-\"P\":+1$<                                                                                                  >70g40g9+50g\"c\"+p  v\r\n                            $                                                         >50g0`40g9+50g\"c\"+g40g9+50g\"d\"+g40g9+50g1+g+:70p`*|\r\n                    |p070g07<                                                         v                                                 <p+\"c\"g05+\"d\"g04\"X\"<\r\n                    >\"O\"9+\"Od\"+g.@                                                                                                            >70g40g55++50g\"d\"+pv\r\n                                                                                      >40g\"P\"-40g55++50g\"d\"+g40g9+50g\"d\"+g40g55++50g2+g+:70p`*|\r\n                                                                                      v                                                       <p+\"d\"g05+\"e\"g04\"X\"<\r\n                                                                                                                                          >70g40g9+50g\"e\"+p\"X\"v\r\n                                                                                      >50g\"P\"-40g9+50g\"e\"+g40g9+50g\"d\"+g40g9+50g3+g+:70p`*|\r\n                                                              ^                                                                           <p+\"e\"g05+\"d\"g04    <\r\n\r\n\r\n         # ... #         # ... #\r\n         . . . .         . . . .\r\n         .  .  .         .  .  .\r\n         . . . .         . . . .\r\n         # ... #         # ... #", "Now, after two pseudo-pathfinding problems we finally get a real one.\r\n\r\nThe right solution would proably be to search online for dijkstras algorithm,\r\nbut I\'m lazy and I kinda remember the essence - so I implement my own algorithm from what I remember about pathfinding :D.\r\n\r\nThe general idea is still the same - we generate a 80x80 grid where each cell contains the minimal distance to the node `[0,0]`.\r\nAt the end we just have to look at the value of `distance[79, 79]`.\r\nInitially all distances are set to an absurdly high number.\r\n\r\nAdditionally we have a a 80x80 marker-grid where we mark cells either `UNKNOWN (#)`, `MARKED (0)` or `FINISHED (1)`.\r\nInitially all cells are Unknown.\r\n\r\nWe start our algorithm by setting `distance[0, 0] = data[0, 0]` and `marker[0, 0] = MARKED`\r\n\r\nThen we execute the main loop until all cells are marked with FINISHED,\r\nin our main loop we do:\r\n\r\n - Search fo a MARKED cell\r\n - Calculate for all 4 directions the distance:\r\n - `distance = distance[x, y] + data[x+1, y]` *(or `x-1`, `y+1`, `y-1`, depending on the direction)*\r\n - If the calculated distance is less than the cached value (`distance[x+1, y]`) update the distance and set the updated cell to MARKED\r\n - Set our current cell to FINISHED (`marker[x, y] = FINISHED`)\r\n\r\nRinse and repeat until finished.", 1, 11718762, 1748, 500, 180, 425185);
	Do(84, "Monopoly odds", "In the game, Monopoly, the standard board is set up in the following way:\r\n\r\n~~~\r\nGO A1 CC1 A2 T1 R1 B1 CH1 B2 B3 JAIL\r\nH2                               C1\r\nT2                               U1\r\nH1                               C2\r\nCH3                              C3\r\nR4                               R2\r\nG3                               D1\r\nCC3                              CC2\r\nG2                               D2\r\nG1                               D3\r\nG2J  F3 U2 F2 F1 R3 E3 E2 CH2 E1 FP\r\n~~~\r\n\r\nA player starts on the GO square and adds the scores on two 6-sided dice to determine the number of squares they advance in a clockwise direction.\r\nWithout any further rules we would expect to visit each square with equal probability: `2.5%`.\r\nHowever, landing on G2J (Go To Jail), CC (community chest), and CH (chance) changes this distribution.\r\n\r\nIn addition to G2J, and one card from each of CC and CH, that orders the player to go directly to jail,\r\nif a player rolls three consecutive doubles, they do not advance the result of their 3rd roll.\r\nInstead they proceed directly to jail.\r\n\r\nAt the beginning of the game, the CC and CH cards are shuffled.\r\nWhen a player lands on CC or CH they take a card from the top of the respective pile and, after following the instructions, it is returned to the bottom of the pile.\r\nThere are sixteen cards in each pile, but for the purpose of this problem we are only concerned with cards that order a movement;\r\nany instruction not concerned with movement will be ignored and the player will remain on the CC/CH square.\r\n\r\nCommunity Chest (2/16 cards):\r\n - Advance to GO\r\n - Go to JAIL\r\nChance (10/16 cards):\r\n - Advance to GO\r\n - Go to JAIL\r\n - Go to C1\r\n - Go to E3\r\n - Go to H2\r\n - Go to R1\r\n - Go to next R (railway company)\r\n - Go to next R\r\n - Go to next U (utility company)\r\n - Go back 3 squares.\r\n\r\nThe heart of this problem concerns the likelihood of visiting a particular square. That is, the probability of finishing at that square after a roll.\r\nFor this reason it should be clear that, with the exception of G2J for which the probability of finishing on it is zero,\r\nthe CH squares will have the lowest probabilities, as `5/8` request a movement to another square,\r\nand it is the final square that the player finishes at on each roll that we are interested in.\r\nWe shall make no distinction between \"Just Visiting\" and being sent to JAIL, and we shall also ignore the rule about requiring a double to \"get out of jail\",\r\nassuming that they pay to get out on their next turn.\r\n\r\nBy starting at GO and numbering the squares sequentially from 00 to 39 we can concatenate these two-digit numbers to produce strings that correspond with sets of squares.\r\n\r\nStatistically it can be shown that the three most popular squares, in order, are `JAIL (6.24%) = Square 10`, `E3 (3.18%) = Square 24`, and `GO (3.09%) = Square 00`.\r\nSo these three most popular squares can be listed with the six-digit modal string: 102400.\r\n\r\nIf, instead of using two 6-sided dice, two 4-sided dice are used, find the six-digit modal string.", "v   XX\r\n  ========================================    v      <     v<\r\n  ???????????????????????????????????????? v<<   v<<<|-\"!\":<|-+98:<\r\n>040p\"}}@\"**58*v             v   _v# -1<  v<10   v 10> v    <    <|<\r\n   v           <                  0    |:+<2?^#*4<2?^#$<         ^<\r\n   >1-:2+0\\1pv                            ^3<    ^3<               -\r\n   |:        <     >>>v >>>v v<         >>>v   >>>v    >>>v        2\r\nv $<               12 v 12 v #^p04<+55$<01 v   01 v    01 v >v     :\r\n>40g::2+1g1+\\2+1p>#^?3>#^?3>++58*%:40p>#^?2>4*#^?2>+4*#^?2>+|>:56*-|\r\n|                   >4^v<>4^ #v<       v<>3^    >3^     >3^\r\n>$58vv             <v $<|-*94:<|-+*294:<|-7:  <    v p04+55$<      <\r\n#v *<  >>>v   >>>v ^    <      <        <\r\n:    $ 01 v   01 v  #>v   >v    >v   >v   >v   >v  #>v   >v   >v   > v\r\n-    >#^?2>4*#^?2>+ :|>1-:|>1 -:|>1-:|>1-:|>1-:|>1-:|>1-:|>1-:|>1-:| #\r\n1>1-::2v>3^    >3^   >55+v>56 +v>64*v>\"\'\"v>5v  >0v  v    <    v    >40g3-   v\r\n |:p2+ <>::1+2g2+1g\\ 2+2g 2+1 g \\`                         v>v       #  >62*v\r\n >$v    ^_v#:<-1p2\\g 05+2 :-1 p 2+2\\ g2+1 :: p 05 g    2+2:_^#>40g492*+-|\r\n   >0>:58* \\`|  >$22 g.32 g.4 2 g.@                 >40g6%1+2/2*5*5+v$  >74*v\r\n     ^+1  <  >#<^#       >#    >#   >#   ># >#   >#         #<      >       v\r\n^<                  <        <                     <                 <  $p04<", "This is not really a mathematical problem (or at least not with my solution).\r\n\r\nAll I did was implement the rules in my befunge program and run a randomized game for `1 000 000` turns.\r\nThis is called an [Monte Carlo algorithm](https://en.wikipedia.org/wiki/Monte_Carlo_algorithm) and if we have enough runs it becomes pretty improbable to get a wrong result.\r\n\r\nPerhaps there are some fancy mathematical solutions out there, but this works too.\r\n\r\nA note to the befunge code: It got pretty messy because of all the decisions we have to implement for the different monopoly rules,\r\nbut all we needed as storage was an 40-element array. So it wasn\'t that hard to fit it all in the 80x25 space.", 0, 146519794, 19203, 77, 20, 101524);
	Do(85, "Counting rectangles", "By counting carefully it can be seen that a rectangular grid measuring 3 by 2 contains eighteen rectangles:\r\n\r\n![Grid Image](/data/blog/Befunge/p085.gif)\r\n\r\nAlthough there exists no rectangular grid that contains exactly two million rectangles, \r\nfind the area of the grid with the nearest solution.", "vX\r\n YY YY YY\r\n>\"}}_!\"+**:10p11p051p071p>10g71g`v\r\n     v*`g18g01`g14g15<p18 g17p141_v\r\nv8g01_51g1+:51p71g+7   1p^   @.g12<\r\n>1g-:0\\`#v_0>-:11g`#v_11p41g5v\r\n>*81g+81v>0\\^v+1g14$<#0p12*g1<\r\n^g17p14:># p#<       ^", "The key to solve this problem is effectively iterating through the permutations for a given width and height (`perms[w, h]`).\r\n\r\nFirst we look at the baseline with `width=1`. The basic case `perms[1,1]` is `1`.\r\nAfter that `perms[1,h] = perms[1,h-1] + h` (so we can iterate easily through all these solutions).\r\n\r\nWith the baseline in place we can see that `perms[w, h] = perms[w, h-1] + perms[w, 1] * h`.\r\n\r\nThen we just iterate through all the possibilities and search for the smallest difference.\r\nWe can stop increasing the width when `perms[w, 1] > 2,000,000` and similar stop increasing the height when `perms[w, h] > 2,000,000` or `w > h`.\r\nThe second conditions stems from the fact that `perms[w, h] == perms[h, w]` *(it\'s a mirrored functions)*.\r\n\r\nThrough these limiting conditions and the fact that each step is pretty fast (just a few additions and multiplications) this algorithm is *really* fast.\r\n*(We only test around 10000 values before our search space is depleted)*", 0, 880151, 109, 35, 8, 2772);
	Do(86, "Cuboid route", "A spider, **S**, sits in one corner of a cuboid room, measuring `6 by 5 by 3`, \r\nand a fly, **F**, sits in the opposite corner. \r\nBy travelling on the surfaces of the room the shortest \"straight line\" \r\ndistance from **S** to **F** is 10 and the path is shown on the diagram.\r\n\r\n![img](/data/blog/Befunge/p086.gif)\r\n\r\nHowever, there are up to three \"shortest\" path candidates for any given cuboid and \r\nthe shortest route doesn\'t always have integer length.\r\n\r\nIt can be shown that there are exactly `2060` distinct cuboids, ignoring rotations, \r\nwith integer dimensions, up to a maximum size of `M by M by M`, \r\nfor which the shortest route has integer length when `M = 100`. \r\nThis is the least value of M for which the number of solutions first exceeds two thousand; \r\nthe number of solutions when `M = 99` is `1975`.\r\n\r\nFind the least value of M such that the number of solutions first exceeds one million.", "v##### ##                                    >       >$30gv >`#v_v\r\n>\"}}@\"**50p040p0>1+:v>>1-::*70g:*+v  vp01g03_^#-g01:_^#- <: g  : :\r\n                    :+  v         <  >:30p:20 g\\/+2/: 30g^* 0>#1v2\r\n                    71 >           >#^ #p #0 2 #<$      v   7gv+</\r\n                    0*  >:88*%\"9\"`#^_:88+%:9`#v_:2-#v_v   2 :082g8\r\n                    p2      >     >     >     > #     >$>$0>|80/0 \r\n                    0p |!-8_^#-7:_^#-6:_^#-5:_^# -3:<     g  +p7^<\r\n                    80            >     ^<   0 <^:p010 <^<-! ^10#<\r\n   >            ^   >^ >:55+%:7-!#^_:3-!#^_2-!#^_:3%2-#^_^>^  $g -\r\n@._^#`g05p04:+g04g08$_^#!:                                  < <>\\^", "The spider essentially travels on the hypotenuse of a triangle with the sides `A` and `B+C`.\r\nFor it to be the shortest path the condition `A <= B+C` must be true.\r\n\r\nThe amount of integer-cuboids for a given value M is \"All integer-cuboids with `A=M`\" plus integer-cuboids(M-1).\r\nIn our loop we start with `M=1` and increment it in every step.\r\nWe also remember the last value (for `M-1`) and loop until the value exceeds one million.\r\n\r\nFor a given value `A = M` we go through all possible `BC` value (`0 <= BC <= 2*A`) and test if `M^2 + BC^2` is an integer-square.\r\nIf such a number is found and `BC <= A` then this means we have found `BC/2` additional cuboids (there are `BC/2` different `B+C = BC` combinations where `B <= C`)\r\nIf, on the other hand `BC > A` then we have only found `A - (BC + 1)/2 + 1` additional cuboids (because the condition`A <= BC` must be satisfied).\r\n\r\nOne of the more interesting parts was the `isSquareNumber()` function, which test if a number `x` has an integer square-root.\r\nTo speed this function up *(it takes most of the runtime)* we can eliminate around 12% of the numbers with a few clever tricks.\r\nFor example if the last digit of `x` is `2`, x is never a perfect square-number. Or equally if the last hex-digit is `7`.\r\nIn our program we test twelve conditions like that:\r\n\r\n~~~\r\nx % 16  > 9\r\nx % 64  > 57\r\nx % 16 == 2\r\nx % 16 == 3\r\nx % 16 == 5\r\nx % 16 == 6\r\nx % 16 == 7\r\nx % 16 == 8\r\nx % 10 == 2\r\nx % 10 == 3\r\nx % 10 == 7\r\nx % 3  == 2\r\n~~~\r\n**Sources:**\r\n - [ask-math.com](http://www.ask-math.com/properties-of-square-numbers.html)\r\n - [johndcook.com](http://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/)\r\n - [stackoverflow.com](http://stackoverflow.com/questions/295579/fastest-way-to-determine-if-an-integers-square-root-is-an-integer)\r\n\r\nIf none of this pre-conditions is true we have to manually test the number.\r\nWe use the same the same [integer-squareroot](https://en.wikipedia.org/wiki/Integer_square_root) algorithm as in previous problems.\r\nIf `isqrt(x)^2 == x` the we can be sure that x is a perfect square number.", 0, 599659030, 91822, 66, 10, 1818);
	Do(87, "Prime power triples", "The smallest number expressible as the sum of a prime square, prime cube, and prime fourth power is 28. \r\nIn fact, there are exactly four numbers below fifty that can be expressed in such a way:\r\n\r\n~~~\r\n28 = 2^2 + 2^3 + 2^4\r\n33 = 3^2 + 2^3 + 2^4\r\n49 = 5^2 + 2^3 + 2^4\r\n47 = 2^2 + 3^3 + 2^4\r\n~~~\r\n\r\nHow many numbers below fifty million can be expressed as the sum of a prime square, \r\nprime cube, and prime fourth power?", "v000000000 \r\n################################################################\r\n# ... #\r\n. . . .\r\n.  .  .\r\n. . . .\r\n# ... #\r\n\r\n>150p0>:50g::+50p\\1pv\r\n      |-\">\":+1      <\r\nv    $<\r\n>\"}\"8* :   8   : 2v>\"X\"\\:10g%\\10g/2+p:40 v\r\nv222p040p03*p01\\p0<:vp+2/g01\\%g01:p04+1:g<\r\n>10g%\\10g/2+g \" \"- |>:::50p+>:30g\\`!#v_:\" \"\\: v\r\n|-g03:::         +1<        ^+g05p+2/ g01\\%g01<\r\n>$$$\"o\"9*:20p10g*:v^                $<\r\nvp050p08*9\"e\"-1p03<\r\n>:0\\:10g%\\1 v\r\n|+1:-1p+3/g0<            v+1                           >#  v#     $$<                 <\r\n>$\"}}P(\"***90p0>:2g:*60p0>:80g\\`!#v_:2g::**60g+:70p90g`#v_0>:80g\\`!#^_:2g:*:*70g+:90g`|\r\n               |-g08:+1$          <                    #<v1+1%\"<\"\\g+3/g01\\%g01:/\"<\":::<\r\n         @.g05$<                                         >g%\\\"<\"%1g/#v_::\"<\"/:10g%\\10g/3+g\\\"<\"%1g+v\r\n                                                       ^+1          $<0p05+1g05p+3/g01\\%g01:/\"<\"\\ <", "Here we iterate quite simply through all the `primes[a]^2 + primes[b]^3 + primes[c]^4` combinations and remember the already found ones.\r\n\r\nThe prime numbers are generated with the help from our old friend the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\r\n*(i improved my befunge snippet for this algorithm a little bit. It\'s now a bit faster and smaller in size)*.\r\n\r\nThe main problem was that we needed an bit-array with an size of **fifty million bits**.\r\nNormally I would simply use an array of size fifty million. But we need to only store Boolean information.\r\nSo I used a \"trick\" were I stored sixty bits per cell (these are 64-bit values, but I wanted to prevent signed/unsigned problems and I had the problem that the stack is also only 64-bit).\r\nUnfortunately befunge has no bit operators. So we had to re-invent bit-setting and bit-getting with division, modulo and addition operators.\r\n\r\nIn the end this didn\'t make the program fast, but the file size is under 1MB. And I think the run time is acceptable.", 1, 181436097, 27067, 1000, 1018, 1097343);
	Do(88, "Product-sum numbers", "A natural number, N, that can be written as the sum and product of a given set of \r\nat least two natural numbers, `{a1, a2, ... , ak}` is called a product-sum number: \r\n`N = a1 + a2 + ... + ak = a1 * a2 * ... * ak`.\r\n\r\nFor example, 6 = 1 + 2 + 3 = 1 × 2 × 3.\r\n\r\nFor a given set of size, k, we shall call \r\nthe smallest N with this property a minimal product-sum number.\r\nThe minimal product-sum numbers for sets of size, `k = 2, 3, 4, 5`, and `6` are as follows.\r\n\r\n~~~\r\nk=2:  4 = 2 * 2 = 2 + 2\r\nk=3:  6 = 1 * 2 * 3 = 1 + 2 + 3\r\nk=4:  8 = 1 * 1 * 2 * 4 = 1 + 1 + 2 + 4\r\nk=5:  8 = 1 * 1 * 2 * 2 * 2 = 1 + 1 + 2 + 2 + 2\r\nk=6: 12 = 1 * 1 * 1 * 1 * 2 * 6 = 1 + 1 + 1 + 1 + 2 + 6\r\n~~~\r\n\r\nHence for `2<=k<=6`, the sum of all the minimal product-sum numbers is `4+6+8+12 = 30`;\r\nnote that 8 is only counted once in the sum.\r\n\r\nIn fact, as the complete set of minimal product-sum numbers for `2<=k<=12`\r\nis `{4, 6, 8, 12, 15, 16}`, the sum is `61`.\r\n\r\nWhat is the sum of all the minimal product-sum numbers for `2<=k<=12000`?", "v XXXX\r\n  OOOO\r\n\r\n### ... ###\r\n### ... ###\r\n### ... ###\r\n\r\n### ... ###\r\n### ... ###\r\n### ... ###\r\n\r\n                                             vp+8+8/g05\\%g05:\\1:p+3/<\r\n>\"`` \"+*20p\"}`\"*30p8:*:*:*:*40p28*8*8*50p20g>:!#v_1-:40g\\:50g%\\50g ^\r\n vp142p13+1g03p122p+8812                       $<v:--g14g13g03g14<\r\n v                          <                    #              _^#-3++`g14g+3/g05\\%g05:--g1<                         <p+3/g05\\%g05:-<\r\n >31g1+31p 082*g::41g\\/\\1+*4 1p1+082*p051p  >41g31g30g21g-+`#v_30g31g41g--1`41g31g`!30g31g4 ^g--:50g%\\50g/3+g41g`++3-#^_41g30g31g41g-^\r\n                            ^p+3/g05\\        %g05<           > 51g:50g%\\50g/82*+g:41g\\/41p3v\r\n vp15+1g15p13+\\g13p14*\\g14:g+*28/g05\\%g05:g1 5p+*28/g05\\%g05:g15g+*28/g05\\%g05:+1g15p13-\\g1<\r\n >51g30g1+-#v_              v               ^                              <\r\n v  p13+1g13<\r\n >51g:50g%\\50g/82*+g::1+51g:50g%\\50g/82*+p 41g\\/41p1+41g*41p51g21g`#v_     ^\r\nvp310p300                   <                                       >51g21p^\r\n                 >3+g61g1+:50g%\\50g/3+p61g:50   v >$$v\r\n    >1pv>71g-  #v v#                 <          #  $_v#`\\g18<\r\n    7v0<^:g+3/g< ^ /g05\\%g05:g16g+3/g 05\\%g05:+1:p16:< >81g-|\r\n>01-^>::50g%\\50^ v_$:0\\:50g%\\5 0g/3+p^>::50g%\\50g/3+g::|    $\r\n     ^_v#-g02:+1<>:71g`#v_81p:>1-:1+  |         # ^  $$<    1  \r\n       $        ^      $># 7#  1 p# <$<0  p+3/g05\\%g05:\\0  +<\r\n    v00<                      ^p+3/g05        \\%<\r\n    v+1                        <\r\n    >::91p50g%\\50g/3+g+91g:30g-|\r\n                               >$.$@", "Let\'s say LIMIT is our maximum value of k (`12 000`).\r\n\r\nWe start with an array of size LIMIT, filled with ones.\r\nOur current sum is `LIMIT` and our current product is `1`.\r\nTo kickstart the whole progress we set `arr[1] = 2` (now sum is `LIMIT+1` and product is `2`).\r\nWe also remember the amount of changed fields, which are possible not one (initial `2`).\r\n\r\nNow we iterate through all the possible array-combinations (with a few tricks to limit the search-space).\r\n\r\n - In each step we increment array[0]. And update the fields sum and product.\r\n   This update is not that complex, sum is incrementing by `1` and\r\n   product is `(product / arr[0]-1) * arr[0]`\r\n - While `prod > sum + (LIMIT - len)` we reset the current `arr[pos]` to `arr[pos + 1]` \r\n   and increment arr[pos + 1] \r\n   (and obviously increment `pos` and update `sum` and `product`)\r\n - After that we have a valid array valud. We can now test for which value of k this is a result\r\n   (and if is is better than a previous found value)\r\n - The value of k is `k := LIMIT - (sum - prod)`\r\n   The trick here is that we generate a solution by cutting away a lot of the ones at the end of our array \r\n   to get a solution where `prod = sum` (cutting ones decreemnts sum but leaves prod unchanged).\r\n - The condition to cut away only ones is given by our previous condition `prod > sum + (LIMIT - len)`.\r\n - After we have gone through all the possible values this way we only have calculate the sum of all the unique values\r\n \r\nBecause in the last step the list is almost sorted (not totally sorted but there arent that many cases where result[i] > result[i+1])\r\nwe can use a need little algorithm which eliminates duplicates by running through the list \r\nand doing sum occasional backtracing with an complexity of almost O(N).\r\n\r\nI know, the algorithm got a bit complex, but it\'s pretty fast - even when converted to befunge.", 1, 141097978, 23852, 1024, 50, 7587457);
	Do(89, "Roman numerals", "For a number written in Roman numerals to be considered valid there are basic rules which must be followed.\r\nEven though the rules allow some numbers to be expressed in more than one way there is always a \"best\" way\r\nof writing a particular number.\r\n\r\nFor example, it would appear that there are at least six ways of writing the number sixteen:\r\n\r\n~~~\r\nIIIIIIIIIIIIIIII\r\nVIIIIIIIIIII\r\nVVIIIIII\r\nXIIIIII\r\nVVVI\r\nXVI\r\n~~~\r\n\r\nHowever, according to the rules only XIIIIII and XVI are valid,\r\nand the last example is considered to be the most efficient, as it uses the least number of numerals.\r\n\r\nThe 11K text file, roman.txt, contains one thousand numbers written in valid,\r\nbut not necessarily minimal, Roman numerals;\r\nsee **About... Roman Numerals** for the definitive rules for this problem.\r\n\r\nFind the number of characters saved by writing each of these in their minimal form.\r\n\r\n*Note:* You can assume that all the Roman numerals in the file contain no more \r\nthan four consecutive identical units.\r\n\r\nAbout... Roman Numerals\r\n=======================\r\n\r\n> How do you read and write Roman numerals?\r\n\r\nTraditional Roman numerals are made up of the following denominations:\r\n\r\n~~~\r\nI = 1\r\nV = 5\r\nX = 10\r\nL = 50\r\nC = 100\r\nD = 500\r\nM = 1000\r\n~~~\r\n\r\nIn order for a number written in Roman numerals to be considered valid there are three basic rules \r\nwhich must be followed.\r\n\r\nNumerals must be arranged in descending order of size.\r\n\r\n`M`, `C`, and `X` cannot be equalled or exceeded by smaller denominations.\r\n\r\n`D`, `L`, and `V` can each only appear once.\r\n\r\nFor example, the number sixteen could be written as `XVI` or `XIIIIII`,\r\nwith the first being the preferred form as it uses the least number of numerals.\r\nWe could not write `IIIIIIIIIIIIIIII` because we are making `X` (ten) from smaller denominations,\r\nnor could we write VVVI because the second and third rule are being broken.\r\n\r\nThe \"descending size\" rule was introduced to allow the use of subtractive combinations.\r\nFor example, four can be written `IV` because it is one before five.\r\nAs the rule requires that the numerals be arranged in order of size it should be clear to\r\na reader that the presence of a smaller numeral out of place, so to speak,\r\nwas unambiguously to be subtracted from the following numeral rather than added.\r\n\r\nFor example, nineteen could be written `XIX` = `X (ten) + IX (nine)`.\r\nNote also how the rule requires `X` (ten) be placed before `IX` (nine),\r\nand `IXX` would not be an acceptable configuration (descending size rule).\r\nSimilarly, `XVIV` would be invalid because `V` can only appear once in a number.\r\n\r\nGenerally the Romans tried to use as few numerals as possible when displaying numbers.\r\nFor this reason, `XIX` would be the preferred form of nineteen over other valid combinations,\r\nlike `XIIIIIIIII` or `XVIIII`.\r\n\r\nBy mediaeval times it had become standard practice to avoid more than three consecutive\r\nidentical numerals by taking advantage of the more compact subtractive combinations.\r\nThat is, `IV` would be written instead of `IIII`,\r\n`IX` would be used instead of `IIIIIIIII` or `VIIII`, and so on.\r\n\r\nIn addition to the three rules given above,\r\nif subtractive combinations are used then the following four rules must be followed.\r\n\r\n - Only one `I`, `X`, and `C` can be used as the leading numeral in part of a subtractive pair.\r\n - `I` can only be placed before `V` and `X`.\r\n - `X` can only be placed before `L` and `C`.\r\n - `C` can only be placed before `D` and `M`.\r\n\r\nWhich means that `IL` would be considered to be an invalid way of writing forty-nine,\r\nand whereas `XXXXIIIIIIIII`, `XXXXVIIII`, `XXXXIX`, `XLIIIIIIIII`, `XLVIIII`, and `XLIX`\r\nare all quite legitimate, the latter is the preferred (minimal) form.\r\nHowever, minimal form was not a rule and there still remain in Rome many examples\r\nwhere economy of numerals has not been employed.\r\nFor example, in the famous Colosseum the numerals above the forty-ninth entrance\r\nis written `XXXXVIIII` rather than `XLIX`.\r\n\r\nIt is also expected, but not required, that higher denominations should be used whenever possible;\r\nfor example, `V` should be used in place of `IIIII`, `L` should be used in place of `XXXXX`,\r\nand `D` should be used in place of `CCCCC`.\r\nHowever, in the church of Sant\'Agnese fuori le Mura (St Agnes\' outside the walls),\r\nfound in Rome, the date, `MCCCCCCVI` (1606), is written on the gilded and coffered wooden ceiling;\r\nI am sure that many would argue that it should have been written `MDCVI`.\r\n\r\nSo if we believe the adage, \"when in Rome do as the Romans do,\"\r\nand we see how the Romans write numerals, then it clearly gives us much more freedom\r\nthan many would care to admit.", "vABCDEFGHIJKLMNOPQRSTUVWXYZ\r\nv0123212342\r\n ????    ?\r\n>092p190p5492*+0p55+v\r\nvp03\"d\"p0*62\"2\"p0*83< >::1g\"0\"-\\v\r\n>\"}\"4*40p\"}\"8*94+0p55+^_v#:-1p1 <v+1       <>-*\\ >42p            22g+22pv\r\n                        >$9:12p>0>:12gg48*-|^10\\_^#`\\g24::g0-\"@\"gg21:-1<:\r\n                                           >:32p 1-:12gg\"@\"-0g:42p22p>:|<\r\n                        v+55\\g1 +1/+55%\"d\":\\g1+1/\"d\"%*8\"}\":\\/*8\"}\":g22$<\r\nMMMMDCLXXII             >%1+1g\\ +++32g\\-92g+92pv\r\nMMDCCCLXXXIII                  |-+9*8\"}\":p21:+1<\r\nMMMDLXVIIII                    >$92g.@\r\n...\r\n...\r\n...", "I don\'t know why this problem has such a high number.\r\n\r\nWe simply parse all the roman numbers in the file and create minimal roman literals from them.\r\nThen we simply sum all the length-differences together.\r\n\r\nAnd it wasn\'t really hard to write algorithms for these two conversions. Both are pretty straight forward.\r\n(And for number->roman we didn\'t even have to go the whole way, we only need the *length* of the result)\r\n\r\nFor the conversion roman->number we first search for the length of the roman literal.\r\nThen we go backwards through the letters and get the value of each letter (cached by the array in line one).\r\nIf the value of the letter is greater than the last value we increment the total value (by the letter value),\r\notherwise we decrement it.\r\nI found it easier to traverse the number backwards because we can cache the value of the last digit and do the algorithm this way with less `g` calls.\r\n\r\nFor the conversion number->optimal_roman_length i found this nice formula:\r\n\r\n~~~\r\n(n/1000) + R[(N%1000)/100] + R[(N%100)/10] + R[N%10]\r\n\r\n// n is our number\r\n// R is defined as an array with { 0, 1, 2, 3, 2, 1, 2, 3, 4, 2 }\r\n~~~", 1, 569231, 78, 73, 1009, 743);
	Do(90, "Cube digit pairs", "Each of the six faces on a cube has a different digit (0 to 9) written on it;\r\nthe same is done to a second cube.\r\nBy placing the two cubes side-by-side in different positions we can form a variety of 2-digit numbers.\r\n\r\nFor example, the square number 64 could be formed:\r\n\r\n~~~\r\n  +-------+     +-------+\r\n /       /|    /       /|\r\n+-------+ |   +-------+ |\r\n|       | |   |       | |\r\n|   6   | +   |   4   | +\r\n|       |/    |       |/\r\n+-------+     +-------+\r\n~~~\r\n\r\nIn fact, by carefully choosing the digits on both cubes it is possible to display\r\nall of the square numbers below one-hundred: `01`, `04`, `09`, `16`, `25`, `36`, `49`, `64`, and `81`.\r\n\r\nFor example, one way this can be achieved is by placing `{0, 5, 6, 7, 8, 9}` on one cube \r\nand `{1, 2, 3, 4, 8, 9}` on the other cube.\r\n\r\nHowever, for this problem we shall allow the `6` or `9` to be turned upside-down \r\nso that an arrangement like `{0, 5, 6, 7, 8, 9}` and `{1, 2, 3, 4, 6, 7}` allows \r\nfor all nine square numbers to be displayed; otherwise it would be impossible to obtain `09`.\r\n\r\nIn determining a distinct arrangement we are interested in the digits on each cube, not the order.\r\n\r\n - `{1, 2, 3, 4, 5, 6}` is equivalent to `{3, 6, 4, 1, 2, 5}`\r\n - `{1, 2, 3, 4, 5, 6}` is distinct from `{1, 2, 3, 4, 5, 9}`\r\n\r\nBut because we are allowing `6` and `9` to be reversed, the two distinct sets in \r\nthe last example both represent the extended set `{1, 2, 3, 4, 5, 6, 9}` for the \r\npurpose of forming 2-digit numbers.\r\n\r\nHow many distinct arrangements of the two cubes allow for all of the square numbers to be displayed?", "v X_XXOO #########                v6$<                 > #g #0 #+ #8 #: #:v#<>v\r\n2 X ##########v 2+4\\1p22+g22!g2+4:< _^#-9:%+55*:p1+4\\1p12+g12!g1+4:/+55*::_v 1g\r\n9 X ##########v1+4\\1p12+g12!g1+4:<   _v#-9:%+55*:p2+4\\1p22+g22!g2+4:/+55*::< 26\r\n3  C          >p                #^6$ #<     #v      >#      #<           1-:|$`\r\n*>020p8>:0\\9+0p:#v_$021p022p9>:0\\4+1p:0\\4+2p:#v_$55+^vg0+9p0+9\\!g0+9::::<   >^2\r\n+p     ^-1       <^00       <^-1              <   v$$_!#v_1- #  #v #! #+^#`6g2<\r\n33                          ^                     <     >$   ^  v_8     ^ \r\n>^                                      @.g02< >:1-\\#v_$         >     8^\r\n              >:0\\4+1p  >:1-\\#v_$     v        |g1+4:<9_v#-g12 6< \r\n               vp1+4\\1:<|g1+4:<9_v#-g125p1+4\\1:<        2>       ^\r\n              ^0       ^<      >#1>:0\\4+1p     >:1-\\#^_$         ^\r\n              $#               ^  $$  <                 #$\r\n            >#^_1-             :!#^_1-                :!#^_@\r\n            !  >                 >                      >22g6- #v _v \r\n  >v        ^:                   ^#                  < >:1-\\#v_$  #2v\r\n  p                   >:0\\4+2p  >:1-\\#v_$     v        |g2+4:<9<< > v\r\n  2                    vp2+4\\1:<|g2+4:<9_v#-g225p2+4\\1:< v          <   >g1+20pv\r\n  +                   ^0       ^<      >#1>:0\\4+2p   # >:1-\\#^_$  ^     ^02p+g<\r\n  9                   $#               ^ #$$  <      ^  $<        $# >%\\\"P\"/33^\r\n>#4>               :!#^_1-             :!#^_1-                 :!#^_@^\"P\":\\g03<\r\n  0 v+64p04+g1+94!g1+64<   >#           #<           #v#          #<     v     #\r\n  p >2g!49+2g+50pv>40g50g+#^_046+1p149+1p046+2p149+2pv>146+1p049+1p146+2p 049vv<\r\n^<^2+641< v0p2+9$0 41p2+640_v#!g05<p1+940p1+641< v p 2#1+941p1+640_v#!g04<p2+<#\r\nv       $#        $#      <   >v          v    $#     $#           #     <  > ^ \r\n>  1+:!#^_1-   :!#^_1-   #^              #< :!#^_1-:!#^_@>33g+g:30g-#v_$$^     <\r\n ^        -#                < 9   ^                                < >57*- !|  #\r\n          >      >060p070p9v<           9p070p060<   <   ^/\"P\"\\%\"P\"::<  v   <\r\n                v*2g06g1+4:<  $v                   <              >\\v^-1<*\" (\"<#\r\n                >+60p:1-\\  #^_^>:4+2g70g2*+70p:1-\\#^_$70g60g:70g`#^_>48*:**+30p^\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################\r\n################################################################################", "We have nine square numbers that need to be represented.\r\nFor each number we can either use dice one for the first digit and dice two for the second or the other way around. Together there are `2^9 (=512)` possibilities.\r\nIn our program we iterate through them all (a simple binary counter at program position [9,0]).\r\n\r\nIn each turn we remember which numbers would need to be written on the first dice and which on the second one (we have two boolean arrays at [4,1] and [4,2]). If one dice needs more than six numbers on it we can directly throw this combination away and go on with the next number in our binary counter.\r\n\r\nIt\'s important that in this phase we have no nines. Every nine is replaced with a six (so we use `3*3 = 09` and `7*7 = 46`) The nines are later taken into account.\r\n\r\nNow most of the time one or both dices have less than six digits on it (sometimes even only four).\r\nWe iterate now through all possible combinations of six digits with our found set as a basis. (So if one dice has 5 digits and the other one 4 we generate an additional 150 combinations (`5*5*6`).\r\n\r\nThen in the last step we look at each dice and see if it contains a six and no nine. If this is the case we generate another combination where the six and the nine is exchanged. (Because we do this for each dice individually we can for each given combination possibly generate four new ones *(original, D1 exchanged, D2 exchanged, both exchanged)*).\r\n\r\nNow we have every possible combinations that fits our initial condition. To weed out all the duplicates we generate a hash from the combination and remember previously found values in an 80x16 big hashmap (originally I had the map way bigger, but after my first successful run I could shrink the size to a more fitting value).\r\n\r\nThe hash is simply the binary representation of **D1** and **D2** concatenated (one for \"has this digit\", zero for \"does not have this digit\").\r\nBecause the order of the dices is irrelevant in our result we ignore it also in our hash and always use the dice with the smaller hash value as the lower bits of the total hash (this way `HASH(D1,D2) == HASH(D2,D1)`).\r\n\r\nOne problem of writing this program (except the metric fuck-ton of code all this needs, seriously I filled a 80x30 grid only with logic, there is more raw code than space for the 1280-elements hashmap) were the filling methods.\r\n\r\nIn my C# test program I had three functions:\r\n\r\n - **PadLeft** fills the left digit up to six digits with all possible values\r\n - **PadRight** fills the right digit up to six digits with all possible values\r\n - **PadNine** exchanges `6` with `9` in the left and right digit to generate all possible combinations\r\n - **Output** Test if a is already in the hashmap, if not increments the counter \r\n\r\nNow the function PadLeft() calls PadRight() which calls PadNine(), which calls Output(). Each at three to four different places.\r\nSo in my befunge program I needed to do the same thing every sane procedural language does:\r\nRemember the back jump address, so after PadNine() is called we know where in PadRight() we have to continue the program flow.\r\n\r\nUnfortunately this is in befunge not really good to write and leads to a lot of boilerplate code, but it\'s still better than writing the Output function twenty-seven times in different places.\r\n\r\nA last note: This is the first program where I put the big data structures below the actual code. It\'s nice to have all the program logic at the top of the file, but every time I address something down there the constants for the Y value take more space. This is also the reason my variables are always in the top left corner, there I can address them with only three commands (`xyg` bzw `xyp`) as long as `x` and `y` are below ten.\r\nSo I think it\'s not too bad to have the data below the code but for the future I will keep my old organization.", 0, 335326352, 54366, 80, 45, 1217);
	Do(91, "Right triangles with integer coordinates", "The points `P(x1, y1)` and `Q(x2, y2)` are plotted at integer co-ordinates and are joined to the origin,\r\n`O(0,0)`, to form `OPQ`.\r\n\r\n![img](/data/blog/Befunge/p091_1.gif)\r\n\r\nThere are exactly fourteen triangles containing a right angle that can be formed when each co-ordinate \r\nlies between 0 and 2 inclusive; that is,\r\n\r\n~~~\r\n0 <= x1, y1, x2, y2 <= 2.\r\n~~~\r\n\r\n![img](/data/blog/Befunge/p091_2.gif)\r\n\r\nGiven that `0 <= x1, y1, x2, y2 <= 50`, how many right triangles can be formed?", "\"2\":11p031p41p>11g51p51g1> #1 #g #<v\r\n X XXXX >$41p#^_31g311g:**+.@>$p v1+\r\n>1g51g:61g-\\*41g%!2*+31p61g1+61pv!56\r\n^  >51g#^ #:1# - #1:#g5#11#4 ^#  _^1\r\n^3_^#!  +`g11g16`*:g14*-\\g16:g15< p<", "This was mostly a mathematical problem.\r\n\r\nLets go step by step through my solution:\r\n\r\nWe have a triangle with three corners, `O(o_x, o_y)`, `Q(q_x, q_y)` and `P(p_x, p_y)`, where `O = (0,0)`.\r\nWe can quickly see that there are three types of solutions, triangles where O has the right angle, \r\ntriangles where Q has the right angle and triangles where P has the right angle.\r\n\r\nThe amount of triangles in group two (angle at Q) and group three (angle at P) are identical (!)\r\nBecause for every triangle in group two there is a triangle in group three which has the points P and Q mirrored at the vertical Axis `(1, 1)`.\r\nSo when we have a triangle `O(0, 0); Q1(q1_x, q1_y); P(p1_x, p1_y)` the corresponding mirrored triangle is\r\n~~~\r\nq2_x = q1_y\r\nq2_y = q1_x\r\np2_x = p1_y\r\np2_y = p1_x\r\n~~~\r\n\r\nThese two groups (two and three) are also mutually exclusive, because if `Q1 == P2` and `Q2 == P1` then the vectors `OP` and `OQ` would have equal length and \r\nthe only possible right angle could be at point O (and not at P or Q).\r\n\r\nNow that we have proven that `count(group_2) == count(group_3)` we only have to find that triangle count and the amount of triangles in group one.\r\n\r\nFirst group one:\r\n\r\nTo have an right angle at the zero point `O(0, 0)` both other points have to lie on an axis.\r\nWe say point Q lies on the x-axis and point P on the Y-axis. All combinations lead to valid and unique triangles, the only disallowed point is the origin `(0, 0)`.\r\nSo we have `SIZE` possible positions on the x-axis and `SIZE` possible positions on the y-axis. This leads to `SIZE * SIZE` different unique triangles:\r\n\r\n~~~\r\ncount(group_1) = SIZE * SIZE\r\n~~~\r\n\r\nNow group 2/3\r\n\r\nBecause we need to define a bit of semantics we say our point Q is the lower-right point of the triangle (and P is the upper left), \r\nsimilar to the project-euler example image. Also we want our right angle to be at point Q (between the vectors OP and PQ).\r\nFirst we can look at the trivial triangles, the ones where Q lies on the x-axis and P has the same x-coordinate as Q. \r\nThese triangles all have an right angle at Q and are valid solutions. And because there are `SIZE` possible positions for Q (all x-axis positions except `(0,0)`) \r\nand for each of these there are `SIZE` possible positions for P (all points on the same x-value as Q, except `y = 0`) \r\nthere are `SIZE*SIZE` trivial triangles with an right angle at Q.\r\n\r\n~~~\r\ncount(group_2_triv) = count(group_3_triv) = SIZE * SIZE\r\n~~~\r\n\r\nFor the remaining triangle we can finally - kind of - start programming.\r\nWe go through all remaining points (q_x, q_y) where `q_x > 0 && q_y > 0` (because the axis are already covered by our trivial cases).\r\n\r\nFor every point (that we assume is Q) we calculate the vector OQ:\r\n\r\n~~~\r\noq_x = q_x - 0 // trivial, yeah i know. In the final program this is all optimized away\r\noq_y = q_y - 0\r\n~~~\r\n\r\nAnd we calculate the direction of the vector QP (under the assumption that Q has a right angle and thus OQ and QP form a right angle). \r\nThis is simply the vector OQ rotate by 90° CW:\r\n\r\n~~~\r\nv_qp_x = -oq_y;\r\nv_qp_y = oq_x;\r\n~~~\r\n\r\nNow we search for integer solutions of `P = Q + n * v_QP`. Each solution, that also falls in our SIZE bounds is a valid triangle.\r\nTo find these we go through all the possible y locations out point P can have.\r\nIt is not possible that one p_y value responds to multiple p_x values, because then QP would be horizontal \r\nand these triangles are already acknowledged in our trivial cases of group_2 / group_3.\r\n\r\nSo for each (possibly valid) p_y value we can calculate the corresponding p_x value:\r\n\r\n~~~\r\np_y = q_y + n * v_qp_y\r\nn   = (p_y - q_y) / v_qp_y\r\n\r\np_x = q_x + n * v_qp_x\r\n    = q_x + ((p_y - q_y) / v_qp_y) * v_qp_x\r\n    = q_x + ((p_y - q_y) * v_qp_x / v_qp_y)\r\n~~~\r\n\r\nFirst we want to test if `(p_y - q_y) * v_qp_x` is a multiple of `v_qp_y`. \r\nIf this were not the case than p_x is not an integer and this is not an integer solution \r\n(then we would simply continue with the next y value until y > SIZE and we have reached our limit).\r\nBut if P(p_x, p_y) **has** two integer components we only need to test if p_x is greater than zero \r\n(because otherwise the triangle would be out of our defined bounds) and then we can increment out triangle counter.\r\nBe aware that we have in this step practically found two unique triangles, this one and its mirrored counter part (see explanation at the beginning).\r\nNow we continue our looping, first until we have tested all possible p_y values (until p_y grows greater than our bounds, SIZE) \r\nand then until we have tested all valid points for Q.\r\n\r\nIn the end we only have to add our values together and we have our result:\r\n\r\n~~~\r\nresult = c_group_1 + 2 * c_group_23\r\n\r\nc_group_23 = c_group_23_triv + c_group_23_nontriv\r\n~~~\r\n\r\nThis is one of the problems that translate **really** well into befunge, because there are no big data structures and not even a lot of calculations. \r\nMost of the work is done before we start to write code and the challenge is finding the correct approach.\r\n\r\n*After note:* I really want a price or something for the compression of this program.\r\nEverything is crunched into a 36x5 rectangle and there are nearly no unused codepoints...", 0, 3072923, 343, 36, 5, 14234);
	Do(92, "Square digit chains", "A number chain is created by continuously adding the square of the digits in a number to \r\nform a new number until it has been seen before.\r\n\r\nFor example,\r\n\r\n44 ? 32 ? 13 ? 10 ? 1 ? 1\r\n85 ? 89 ? 145 ? 42 ? 20 ? 4 ? 16 ? 37 ? 58 ? 89\r\n\r\nTherefore any chain that arrives at 1 or 89 will become stuck in an endless loop. \r\nWhat is most amazing is that EVERY starting number will eventually arrive at 1 or 89.\r\n\r\nHow many starting numbers below ten million will arrive at 89?", "v $$ T # #######################################################################\r\n       # #######################################################################\r\n  XX   # #######################################################################\r\n       # #######################################################################\r\n       # #######################################################################\r\n       # #######################################################################\r\n       # #######################################################################\r\n       # #######################################################################\r\n\r\n v                                   p1*93\"Y\" p0+551 $<\r\n> \"G\"8*:32p\"}2((\"***22p020p030p  >1-:0\\:\"G\"%9+\\\"G\"/p:!|\r\n             v     pp02+1:g027:$<^              ># v# <\r\n >22g:>:32g`#v_::\"G\"%9+\\\"G\"/g:!#^_:1-!#v_  :\"Y\"-|  #     >1-:20p7\\g50g\\:  v\r\n             >0\\>:55+%:*\\ :#v_$$11v    >30g1+30p>50p$20g:|:g02p/\"G\"\\+9%\"G\"<\r\n        >3     v^/+55g05+p05< >$@ v1                ::-1$<\r\n      ^_^#  _^#># 0# g# .# $# ^#  <*0              <", "My approach to this problem is pretty crude. Perhaps I will later come back and try to find a better algorithm.\r\nCurrently we iterate (brute-force) through all possible numbers and count the chains that end with one.\r\nThe `next()` function is implemented like this:\r\n\r\n~~~~~~~~~~~~~~~~~~~\r\n0\\>:55+%:*\\ :#v_$$\r\n  ^/+55g05+p05<   \r\n~~~~~~~~~~~~~~~~~~~\r\n\r\nWe also remember in an 8x71 cache all previously found numbers so we can abort some sequences before we reach `1` or `89`.\r\nThis is the main optimization from pure brute-force in this program.\r\n\r\nWe can prove that an 568-element cache is enough because no number in the sequence (except the first) can be greater than `9^2 * 7` (` = 567`)", 0, 2959813630, 379925, 80, 16, 8581146);
	Do(93, "Arithmetic expressions", "By using each of the digits from the set, `{1, 2, 3, 4}`, exactly once, \r\nand making use of the four arithmetic operations (`+`, `?`, `*`, `/`) and brackets/parentheses, \r\nit is possible to form different positive integer targets.\r\n\r\nFor example,\r\n\r\n~~~\r\n8  =  (4   *  (1   +   3)) /   2\r\n14 =   4   *  (3   +   1   /   2)\r\n19 =   4   *  (2   +   3)  ?   1\r\n36 =   3   *   4   *  (2   +   1)\r\n~~~\r\n\r\nNote that concatenations of the digits, like `12 + 34`, are not allowed.\r\n\r\nUsing the set, {1, 2, 3, 4}, it is possible to obtain thirty-one different target numbers \r\nof which 36 is the maximum, and each of the numbers 1 to 28 can be obtained \r\nbefore encountering the first non-expressible number.\r\n\r\nFind the set of four distinct digits, `a < b < c < d`, for which the \r\nlongest set of consecutive positive integers, 1 to n, can be obtained, \r\ngiving your answer as a string: abcd.", "v XXXX   ####################################################################################################\r\n  XX     ####################################################################################################\r\n         ####################################################################################################\r\n  C      ####################################################################################################\r\n OOOO    ####################################################################################################\r\n         ####################################################################################################\r\n OOOO  O ####################################################################################################\r\n OOOO  O ####################################################################################################\r\n OOOO  O ####################################################################################################\r\n OOOO  O ####################################################################################################\r\n         ################    ...                ...                ...                ...    ################\r\n0        ####################################################################################################\r\n2        ####################################################################################################\r\n1        ####################################################################################################\r\np        ####################################################################################################\r\n\"        ####################################################################################################\r\nH        ####################################################################################################\r\n#        ####################################################################################################\r\n\"        ####################################################################################################\r\n*        ####################################################################################################\r\n2        ####################################################################################################\r\n3        ####################################################################################################\r\np        ####################################################################################################\r\n0        ####################################################################################################\r\n3        ####################################################################################################\r\n1        ####################################################################################################\r\np        ####################################################################################################\r\n\r\n>\"}P\"*>1-:\" \"\\:\"d\"v\r\n      |:p/\"d\"\\+9% <\r\nv    $<  >4g.24g.34g.44g.@\r\n>120p>20g1+30p    >30g1+40p    >40g1+50p    > \"X\" 20g55+*30g+50g55+*40v\r\n     |-7p02:+1g02<|-8p03:+1g03<|-9p04:+1g04<|-5-5p05:+1g05p13+1g13p+g <\r\nv    <   #       ^<           ^<           ^<\r\n> 31g1-!#^_21g1+21p031p>120p>20g1+30p    >30g1+40p    >40g1+50p    >20g55+*30g+50g55+*40g+g\"X\"-v\r\n                            |-7p02:+1g02<|-8p03:+1g03<|-9p04:+1g04<|-5-5p05:+1g05<             _v\r\n^                           <           ^<           ^<           ^<            >^\r\n    vp670p64*g32g05p63*g32g04p62*g32g03p61*g32g02                         >#     ^#             <\r\n    v                                      <v                                    <v                          <\r\n    >76g:1+76pv                             >77g:1+77pv                           >78g:1+78pv                ^\r\n>  #v  #:    #<                                #v #: #<                         ^     v:    <\r\n v-1_$077p16g26g+17p36g27p46g37p            ^v-1_$078p17g27g+18p37g28p            ^v-1_$18g28g+19p            v\r\n >: v                                        >: v                                  >: v\r\n v-1_$077p16g36g+17p26g27p46g37p            ^v-1_$078p17g37g+18p27g28p            ^v-1_$18g28g-19p            v\r\n >: v                                        >: v                                  >: v\r\n v-1_$077p16g46g+17p26g27p36g37p            ^v-1_$078p37g18p27g17g+28p            ^v-1_$28g18g-19p            v\r\n >: v                                        >: v                                  >: v\r\n v-1_$077p46g17p26g16g+27p36g37p            ^v-1_$078p17g18p27g37g+28p            ^v-1_$18g28g*23g/19p        v\r\n >: v                                        >: v                                  >: v\r\n v-1_$077p16g17p26g36g+27p46g37p            ^v-1_$078p27g18p37g17g+28p            ^v-1_$28g!#v_18g23g*28g/19p v\r\n >: v                                        >: v                                  >: v      >               ^\r\n v-1_$077p16g17p26g46g+27p36g37p            ^v-1_$078p17g18p37g27g+28p            ^v $_$18g!#v_28g23g*18g/19p v\r\n >: v                                        >: v                                ^ <         >               ^\r\n v-1_$077p46g17p26g27p36g16g+37p            ^v-1_$078p17g27g-18p37g28p            ^   <\r\n >: v                                        >: v                                     |+!!%g32g91!!-g12/g32g91<\r\n v-1_$077p16g17p46g27p36g26g+37p            ^v-1_$078p17g37g-18p27g28p            ^   3\r\n >: v                                        >: v                                     1\r\n v-1_$077p16g17p26g27p36g46g+37p            ^v-1_$078p37g18p27g17g-28p            ^   g\r\n >: v                                        >: v                                     1\r\n v-1_$077p36g17p26g27p46g16g+37p            ^v-1_$078p17g18p27g37g-28p            ^   +\r\n >: v                                        >: v                                     3\r\n v-1_$077p16g17p36g27p46g26g+37p            ^v-1_$078p27g18p37g17g-28p            ^   1\r\n >: v                                        >: v                                     p\r\n v-1_$077p16g17p26g27p46g36g+37p            ^v-1_$078p17g18p37g27g-28p            ^   2\r\n >: v                                        >: v                                     0\r\n v-1_$077p16g26g-17p36g27p46g37p            ^v-1_$078p17g27g*23g/18p37g28p        ^   g\r\n >: v                                        >: v                                     1\r\n v-1_$077p16g36g-17p26g27p46g37p            ^v-1_$078p17g37g*23g/18p27g28p        ^   4\r\n >: v                                        >: v                                     p\r\n v-1_$077p16g46g-17p26g27p36g37p            ^v-1_$078p37g18p27g17g*23g/28p        ^   3\r\n >: v                                        >: v                                     0\r\n v-1_$077p46g17p26g16g-27p36g37p            ^v-1_$078p17g18p27g37g*23g/28p        ^   g\r\n >: v                                        >: v                                     2\r\n v-1_$077p16g17p26g36g-27p46g37p            ^v-1_$078p27g18p37g17g*23g/28p        ^   4\r\n >: v                                        >: v                         p           p\r\n v-1_$077p16g17p26g46g-27p36g37p            ^v-1_$078p17g18p37g27g*23g/28p        ^   4\r\n >: v                                        >: v                         ^44g05p4 3g0<\r\n v-1_$077p46g17p26g27p36g16g-37p            ^v-1_$27g!#v_078p17g23g*27g/18p37g28p ^\r\n >: v                                        >: v      >                         ^\r\n v-1_$077p16g17p46g27p36g26g-37p            ^v-1_$27g!#v_078p17g23g*37g/18p27g28p ^\r\n >: v                                        >: v      >                         ^\r\n v-1_$077p16g17p26g27p36g46g-37p            ^v-1_$27g!#v_078p37g18p27g23g*17g/28p ^\r\n >: v                                        >: v      >                         ^\r\n v-1_$077p36g17p26g27p46g16g-37p            ^v-1_$27g!#v_078p17g18p27g23g*37g/28p ^\r\n >: v                                        >: v      >                         ^\r\n v-1_$077p16g17p36g27p46g26g-37p            ^v-1_$27g!#v_078p27g18p37g23g*17g/28p ^\r\n >: v                                        >: v      >                         ^\r\n v-1_$077p16g17p26g27p46g36g-37p            ^v $_$27g!#v_078p17g18p37g23g*27g/28p ^\r\n >: v                                      ^ <         >                         ^\r\n v-1_$077p16g26g*23g/17p36g27p46g37p        ^\r\n >: v\r\n v-1_$077p16g36g*23g/17p26g27p46g37p        ^\r\n >: v\r\n v-1_$077p16g46g*23g/17p26g27p36g37p        ^\r\n >: v\r\n v-1_$077p46g17p26g16g*23g/27p36g37p        ^\r\n >: v\r\n v-1_$077p16g17p26g36g*23g/27p46g37p        ^\r\n >: v\r\n v-1_$077p16g17p26g46g*23g/27p36g37p        ^\r\n >: v\r\n v-1_$077p46g17p26g27p36g16g*23g/37p        ^\r\n >: v\r\n v-1_$077p16g17p46g27p36g26g*23g/37p        ^\r\n >: v\r\n v-1_$077p16g17p26g27p36g46g*23g/37p        ^\r\n >: v\r\n v-1_$077p36g17p26g27p46g16g*23g/37p        ^\r\n >: v\r\n v-1_$077p16g17p36g27p46g26g*23g/37p        ^\r\n >: v\r\n v-1_$077p16g17p26g27p46g36g*23g/37p        ^\r\n >: v\r\n v-1_$26g!#v_077p16g23g*26g/17p36g27p46g37p ^\r\n >: v      >                               ^\r\n v-1_$36g!#v_077p16g23g*36g/17p26g27p46g37p ^\r\n >: v      >                               ^\r\n v-1_$46g!#v_077p16g23g*46g/17p26g27p36g37p ^\r\n >: v      >                               ^\r\n v-1_$16g!#v_077p46g17p26g23g*16g/27p36g37p ^\r\n >: v      >                               ^\r\n v-1_$36g!#v_077p16g17p26g23g*36g/27p46g37p ^\r\n >: v      >                               ^\r\n v-1_$46g!#v_077p16g17p26g23g*46g/27p36g37p ^\r\n >: v      >                               ^\r\n v-1_$16g!#v_077p46g17p26g27p36g23g*16g/37p ^\r\n >: v      >                               ^\r\n v-1_$26g!#v_077p16g17p46g27p36g23g*26g/37p ^\r\n >: v      >                               ^\r\n v-1_$46g!#v_077p16g17p26g27p36g23g*46g/37p ^\r\n >: v      >                               ^\r\n v-1_$16g!#v_077p36g17p26g27p46g23g*16g/37p ^\r\n >: v      >                               ^\r\n v-1_$26g!#v_077p16g17p36g27p46g23g*26g/37p ^\r\n >: v      >                               ^\r\n v $_$36g!#v_077p16g17p26g27p46g23g*36g/37p ^\r\n^          >#              #<              ^\r\n >\" \"20g55+*30g+50g55+*40g+p^", "This one needs a little bit of a bigger explanation:\r\n\r\nFirst let me say that I\'m aware that this is neither the fastest algorithm nor the best algorithm to represent in funge-space. But its reasonable fast and I liked the challenge of doing such a big program (in terms of raw code size) in befunge.\r\n\r\nFirst we take a 4-dimensional cache of all possible number combinations (so an `bool[10][10][10][10]` array) where we remember if a combination is valid.\r\nIn our program we represent it as an 2D-field with `X=s1*10+s2` and `Y=s4*10+s3`.\r\n\r\nInitially we set all fields to true where `0<s1<s2<s3<s4<10`\r\n\r\nNow we first test all combinations if they can produce `1` and remove the ones from our cache that can\'t.\r\nThen we do `2`, then `3` and so on until only one combination is left. This combination will be our solution.\r\n\r\nThe interesting part (with an quite bad algorithm) is determining if a combination can produce a specific target number. (*For better understanding it could be good to look at the C# version of this problem in this git repo*)\r\n\r\nIn the first step we combine all possible two numbers together (with all 4 possible operators) so we get the same problem with three numbers and a target value. There are in total 48 unique ways of trimming the combination down to three numbers:\r\n\r\n~~~\r\n[s1+s2, s3, s4]\r\n[s1-s2, s3, s4]\r\n[s1*s2, s3, s4]\r\n[s1/s2, s3, s4] if s2 != 0\r\n[s1+s3, s2, s4]\r\n[s1-s3, s2, s4]\r\n[s1*s3, s2, s4]\r\n[s1/s3, s2, s4] if s3 != 0\r\n[s1+s4, s2, s3]\r\n[s1-s4, s2, s3]\r\n[s1*s4, s2, s3]\r\n[s1/s4, s2, s3] if s4 != 0\r\n...\r\n~~~\r\n\r\nThis is more or less a [divide and conquer](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms) algorithm (but the divide part is kinda missing :D )\r\n\r\nNext we do the same for now three numbers and a target value (now there are only 24 ways of combining the numbers) to get only two values\r\n\r\nThen (as you could have guessed) we do the same for two value (8 combinations, but only 6 unique ones)\r\n\r\nAnd in the last step we only have to test if the number equals the target.\r\n\r\nIn our top-most method (let\'s call it **test_0()** ) there are then two possibilities: \r\nEither all 48 code paths failed and we can scratch that combination from our cache, or one succeeded and we keep it.\r\n\r\nThis algorithm makes (heavy) use of the callstack. One method is calling another one many times with different parameter and this one is calling the next (up until four layers deep).\r\nIn befunge we have nothing like a callstack so we need to do all the management of parameters, state and return position by hand.\r\nBut one thing works in our favor: At each time every method is at most one type on the callstack (no recursion or similar stuff here).\r\nBecause of that we can write the parameter and program-counter to fixed position on the funge grid for each method.\r\nIt will never be the case that two calls override each others state.\r\n\r\nUp until here everything sounds nice and friendly. The problem stems from the division operation.\r\nBefunge only understands integer numbers, but in this program it is possible that a intermediate value is a fraction (but the end result still is an integer).\r\nI was not *that* far away from implementing fractions into this program, but fortunately (the runtime is thanking me :D ) there is another way.\r\nWe pre-multiply all numbers by a fixed value (this is called [fixed-point arithmetic](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)).\r\nThe challenge was to find the correct factor.\r\nIt should be an integer that is divisible by all numbers from one to ten, so no single division can introduce errors.\r\nAnd the smallest number is `2520`, this magic number will be the factor for our fixed-point arithmetic.\r\n\r\nWhen doing fixed-point arithmetic addition and subtraction are straight-forward:\r\n\r\n~~~\r\nC = A+B   =>   n*C = n*A + n*B\r\n~~~\r\n\r\nA little more attention is needed when doint multiplication and division, for the first we have to divide by the factor after the operation and for the second we have to multiply it:\r\n\r\n~~~\r\nC = A*B   =>   n*C = (n*A * n*B) / n\r\nC = A/B   =>   n*C = ((n*A)*n / (n*B)\r\n~~~\r\n\r\nIt is important that we multiply the dividend by the factor and not the result of the division, otherwise the decimal places will get lost.\r\n\r\nAs usual a final note from me: Nice problem. 10/10 would solve again", 1, 305514916, 42167, 111, 211, 1258);
	Do(94, "Almost equilateral triangles", "It is easily proved that no equilateral triangle exists with integral length sides and integral area. \r\nHowever, the almost equilateral triangle 5-5-6 has an area of 12 square units.\r\n\r\nWe shall define an almost equilateral triangle to be a triangle \r\nfor which two sides are equal and the third differs by no more than one unit.\r\n\r\nFind the sum of the perimeters of all almost equilateral triangles with integral side lengths \r\nand area and whose perimeters do not exceed one billion (1,000,000,000).", "\"}}2( \"****04003pp201p102p>04g01g2*`#v_v\r\nXv2*2g10**!%3*g20-2g10!-1%3*g102`2g10< 0\r\nX>-*03g+03p01g2*3%2-!01g2+# 02g*3%v    3\r\nXv*2g10+*2g20g10p30+g30*+* g1022*!< @.g<\r\nC>02g3*+01p02p            ^", "Nothing much to say about this one, we play a bit with the triangle formulas until we reach something that looks like a [Pell equation](https://en.wikipedia.org/wiki/Pell%27s_equation).\r\nMy approach is basically the same as the one on [mathblog.dk](http://www.mathblog.dk/project-euler-94-almost-equilateral-triangles/), but he explains it better.\r\n(And I improved my approach a bit after I read his article, his math skills are pretty good :D).\r\n\r\nThe code is in a way interesting because it only has a single conditional operator.\r\nI could remove two conditional by multiplying the increment with the normalized condition (`0`|`1`).\r\nThis way `if (condition) { x += increment; }` becomes ` x +=  (int)(condition) * increment`, \r\nwhich is a neat way to safe a bit of space in our program (and the resulting 40x5 code is pretty compact)", 0, 2009, 0, 40, 5, 518408346);
	Do(95, "Amicable chains", "The proper divisors of a number are all the divisors excluding the number itself.\r\nFor example, the proper divisors of 28 are 1, 2, 4, 7, and 14.\r\nAs the sum of these divisors is equal to 28, we call it a perfect number.\r\n\r\nInterestingly the sum of the proper divisors of 220 is 284 and the sum of the\r\nproper divisors of 284 is 220, forming a chain of two numbers.\r\nFor this reason, 220 and 284 are called an amicable pair.\r\n\r\nPerhaps less well known are longer chains.\r\nFor example, starting with 12496, we form a chain of five numbers:\r\n\r\n~~~\r\n12496 -> r -> 15472 -> 14536 -> 14264 (-> 12496 -> ...)\r\n~~~\r\n\r\nSince this chain returns to its starting point, it is called an amicable chain.\r\n\r\nFind the smallest member of the longest amicable chain with no element exceeding one million.", "v      # ##  ....  ##        ##  ....  ##\r\n   X   # ##        ##        ##        ##\r\n XXX   #                                 \r\n XX    # .          .        .          .\r\n X     # .          .        .          .\r\n X     # .          .        .          .\r\n       # .          .        .          .\r\n       #                                 \r\n       # ##  ....  ##        ##  ....  ##\r\n CCC   # ##        ##        ##        ##\r\n\r\n>\"}\"8*19p\"q\"9*29p\"}}@\"**39p012p014p39g15p39g>1-:0\\:19g/9+\\19g%p v\r\nv                  <                        |:p%g91\\+g92/g91:\\0:<\r\n1     v+1p%g91\\+g92 /g91:\\+g31g%g91\\+g92/g91 ::<\r\n>:13p2>:13g*:39g\\`#^                    #$ #<  |\r\n^_$# 6# v#                            -g93:+1$$<                                    vp51g\\7:<\r\nv       <            >v>g+\\19g%g22pv      >v      >v     >v           >                                   v\r\n> :23p :19g/9+\\19g%g!|> 23g:70p11v >22g:0`|>:39g\\`|>:23g-|$  >:7\\g22g-|             #      > 32g14p:7\\g15pv\r\n|     -g93:+1    g32 <                   $<       <      <0  ^     <  >131p:12g\\-32p32g14g`||*g13`\\g51g\\7:<\r\n>$15g.@                ^92/g91:p2< ^p22g%g<               >31p032p0^       <               v               \r\n                      >9g%p22g:19g/29g+\\19^                          v<    |-g21:+1 <       <              \r\n                     ^                             <                 <|g13$<               < \r\n                      ^1\\+9/g91:\\1pp21+1:g217:g22<_^#!g%g91\\+9/g91:g22<", "The trick is to use a sieve to pre-calculate all the proper-divisor-sums.\r\nWe use a big 1000x1000 array to store all the proper-divisor-sums of all numbers from one to one million.\r\nInitially we set all these fields to zero, then we add `1` to all multiples of `1`, the `2` to all multiples to `2` etc, etc.\r\nAt the end we have a nice map of all the interesting numbers. (Fun fact: we have also calculated the primes, every number for which the sum is `1` is prime).\r\n\r\nThen we use a second 1000x1000 array to remember the values we have already checked.\r\nThe rest is simply iterating through all the numbers, trying to build a chain for each one and remembering the length of the longest chain together with its smallest member.\r\nWhile doing this we track the visited values in our cache array to prevent checking the same chain multiple times.\r\n\r\nThis code is not the fastest in befunge, but I honestly can\'t see a way to gain big performance (the same code in C# runs in 107ms).\r\nMost of the time is spend with building the map of the amicable values, but all approaches with calculating them on-demand where way worse than this algorithm.", 1, 1053466251, 242737, 2017, 1035, 14316);
	Do(96, "Su Doku", "Su Doku (Japanese meaning number place) is the name given to a popular puzzle concept.\r\nIts origin is unclear, but credit must be attributed to Leonhard Euler\r\nwho invented a similar, and much more difficult, puzzle idea called Latin Squares.\r\nThe objective of Su Doku puzzles, however, is to replace the blanks (or zeros)\r\nin a 9 by 9 grid in such that each row, column, and 3 by 3 box contains\r\neach of the digits 1 to 9.\r\nBelow is an example of a typical starting puzzle grid and its solution grid.\r\n\r\n~~~~~~~~~~~~~~~~~~~~~\r\n0 0 3   0 2 0   6 0 0\r\n9 0 0   3 0 5   0 0 1\r\n0 0 1   8 0 6   4 0 0\r\n\r\n0 0 8   1 0 2   9 0 0\r\n7 0 0   0 0 0   0 0 8\r\n0 0 6   7 0 8   2 0 0\r\n\r\n0 0 2   6 0 9   5 0 0\r\n8 0 0   2 0 3   0 0 9\r\n0 0 5   0 1 0   3 0 0\r\n~~~~~~~~~~~~~~~~~~~~~\r\n\r\n~~~~~~~~~~~~~~~~~~~~~\r\n4 8 3   9 2 1   6 5 7\r\n9 6 7   3 4 5   8 2 1\r\n2 5 1 	8 7 6   4 9 3\r\n\r\n5 4 8   1 3 2   9 7 6\r\n7 2 9   5 6 4   1 3 8\r\n1 3 6 	7 9 8   2 4 5\r\n\r\n3 7 2   6 8 9   5 1 4\r\n8 1 4   2 5 3   7 6 9\r\n6 9 5 	4 1 7   3 8 2\r\n~~~~~~~~~~~~~~~~~~~~~\r\n\r\nA well constructed Su Doku puzzle has a unique solution and can be solved by logic,\r\nalthough it may be necessary to employ \"guess and test\" methods in order to eliminate\r\noptions (there is much contested opinion over this).\r\nThe complexity of the search determines the difficulty of the puzzle;\r\nthe example above is considered easy because it can be solved by straight forward\r\ndirect deduction.\r\n\r\nThe 6K text file, [sudoku.txt](https://projecteuler.net/project/resources/p096_sudoku.txt) (right click and \'Save Link/Target As...\'),\r\ncontains fifty different Su Doku puzzles ranging in difficulty,\r\nbut all with unique solutions (the first puzzle in the file is the example above).\r\n\r\nBy solving all fifty puzzles find the sum of the 3-digit numbers found in the top\r\nleft corner of each solution grid; for example, 483 is the 3-digit number found in the\r\ntop left corner of the solution grid above.", "v XX  X ###########  ###########  #############################        #############################                            003 ... 007\r\n C    C #     3 17#  #         #  #                           #        #                           #                            900 ... 000\r\n PPPPP  # 15  9  8#  #         #  #                           #        #                           #                            001 ... 500\r\n XXX    # 6       #  #         #  #                           #        #                           #                             .  . .  . \r\n LLLLLL #1    7   #  #         #  #                           #        #                           #                             .   .   . \r\n PMMMM  #  9   2  #  #         #  #         ##########        #        #                           #                             .  . .  . \r\n MM MMM #   5    4#  #         #  #     ##################    #        #                           #                            002 ... 000\r\n0XXX XX #       2 #  #         #  #     ##################    #        #                           #                            \r\n7       #5  6  34 #  #         #  #   ####################### #        #                           #                            \r\n7       #34 2     #  #         #  #   ####################### #        #          #######          #                            \r\n*       ###########  ###########v<# ####################      #        #       ############        #                            \r\n>     #v                       #<v# ####################      #        #      ###############      #                            \r\n       >    492*+11p9:*:9*61p>1-v## ################          #        #     #################     #                            \r\n   >9+\\9/1+p:0\\:9%11g+\\9/1+p:|    # ############              #        #     #################     #                            \r\n   ^%9:\\+*86%+88 g+1/9\\+9%9::$#:< # ############              #        #     ######## ########     #                            \r\nv1/*93\\+*75%*93:\\0:-1<g16p021<    # ################          #        #     #################     #                            \r\n>+p:0\\:39*%89*+\\39*/#| 1#:+# p# < # ####################      #        #     #################     #                            \r\nv               p030$<>p152p::9%v #   ####################### #        #      ###############      #                            \r\n>9:*>1-:9/32p:9%22p212^vg+1/9\\+9< #   ####################### #        #       ############        #                            \r\nv10  $<   >           v>68*-:42pv #   ####################### #        #          #######          #                            \r\n4   ^_^#:             #      <v!< #     ##################    #        #                           #                            \r\np              >1-:9%24p:9/3v^_ v #         ##########        #        #                           #                            \r\n>30g9:*-!#^_9:*^      >    #4    v#         ##########        #        #                           #                            \r\n v0p450_v#!-*86 g+g431+g429p<$   ##                           #        #                           #v                          <\r\n    >   >    :#^_$14g#v_015p   v  #                           #        #                           #         v            _$:1+|\r\n^                 p410<          ##                           #        #                           #1>+\\g13g9 %9+13g9/1+p:^   v<\r\np6   v:p45+1g44             < >  ^#                           #        #                           #-^+**882* 9/5g06%9g31+*9< $ \r\n4>4p9 >1-:44p57*24g3*44g3%+v      #                           #        #                           # >:60p99*>1-::13p9/60g5%^ . \r\n1   #>|:_v#g++/3g44*3g431+ <      #############################        ############################# ^      <         \\++-*86<@ \r\n0     $  >64g1+64p          ^|^ #>#                                                                #<:77*-!#^_\\91g68*-55+*55v   \r\n    ^             <         $<v>#              #<                     >025p035p045p9:*:*55p9:*>1-: 9%16p:9/26p916gvv+-*86g1+<   \r\n      >64g:!#v_1-#^_14g1+14pv#> >42g68*+22g9+3 v                      ^      < v _v#!g54    $_^#!:<_v#<-*86g+g621+<>55+*56+1g^  \r\n  v        $$<vg43p22g42p211<:  v9p03+1g03p+1g2<^             p25g02<  v02:+1 g 02<vg65$_ v0p650p640< ^1         <<             \r\n              >32p54g42p20g5v-  >1-:13p\"X\"57*22g3*13g3%++132g3*13g3v   >p11g2 5 g+v!    ! >1+:66p57*16g3*66g1-3%v               \r\n >>01-::17p27p37p9:*v_$ 9v  21   vg++/3g31*3g231++%3g31*3g22*98p++/< vp210p+g 5 31<5>pv  < _v#g++/3-1g66*3g621++<               \r\n   v94p76/9:p75%9:-1<^:<<:  p  v _52g89*22g3*13g3%v                  >25g22p3 5 gv 56 : -   >56g1+56p4 v                        \r\n   >2*+57g+167g+g20g-  |p:  > ^:|:p++/3g31*3g231++<                 ^ p24g54p 2 3< g4 >9^|+!`g51g66!!g6<          p             \r\n        v*86g+g761+g759<7*      >$9>1-:23p\"X\"57*23g3*42g1-3%++132g3*42g1-3v        5^g66 <>                      ^5             \r\n        >-17p57g27 p67g3^*      #   vg++/3-1g24*3g231++%3-1g24*3g32*98p++/<        >6g`!+#^_16g25p26g35p46g45p56g5^             \r\n   v*98p76/*93:p75%*93:-1< _$ v>^v  _52g89*23g3*42g1-3%v v >#                ^#<                                                \r\n   >57g+167g+g20g-!    #v_:^< 2  >:|:p++/3-1g24*3g231++<                                                                        \r\n   v75*750p+g761+g75*980<  :: 0v19$<>p\"X\"57*22g3*42g1-3%+ + 133g3*42g1-3/++v                                                    \r\n    >167g3/+g         68*-!|  g>-:33^vg++/3-1g24*3g331++% 3 -1g24*3g22*98p <                                                    \r\n    ^+/3g759<v61+/ 3g759*86<  1^1 < v_52g89*22g3*42g1-3%v                                                                       \r\n   >g+167g+p^>7g3/+p30g1-30p^ -   |:< p++/3-1g24*3g331++<                                                                       \r\n   vp51g71p+g731+g72+*2940p02 <   >$9>1-::3%23p3/33p\"X\"57 * 22g3/3*23g+3*42g1-3%++132g3/3*33g+3*42gv\r\n ^ >#             #<v  >     ^ v># #<^ vg++/3-1g24*3+g33* 3 /3g231++%3-1g24*3+g32*3/3g22*98p++/3-1 <\r\n^                    $_^#!:g21$<   v  :_52g89*22g3/3*23g+ 3 *42g1-3%v\r\n                   ^>#       #<v^  _^#: p++/3-1g24*3+g33* 3 /3g231++<\r\n                              ^>#                       #< ^", "This problem boils down to implementing a sudoku solver.\r\nSo thats what I did (initially as a stand-alone project).\r\nAnd then I wrote a program around that inputs the 5  puzzles \r\ninto the solver and calculates the result.\r\n\r\nThis means in this post I\'m trying to describe how to build a sudoku solver in befunge.\r\n\r\nBecause all the logic is practically a stand-alone sudoku solver, I simply wrote one. You can read about the development and a few of my design decisions in [this blogpost here](https://www.mikescher.com/blog/9/A_complete_sudoku_solver_in_Befunge93).\r\nThe rest was looping 50 times through the solver code and adding the results together.\r\n\r\nReally all the interesting stuff is written in the blogpost about the sudoku solver, go read it!", 1, 583893708, 90918, 218, 50, 24702);
	Do(97, "Large non-Mersenne prime", "The first known prime found to exceed one million digits was discovered in 1999, \r\nand is a Mersenne prime of the form `2^6972593?1`;\r\nit contains exactly 2,098,960 digits. \r\nSubsequently other Mersenne primes, of the form `2^p?1`, have been found which contain more digits.\r\n\r\nHowever, in 2004 there was found a massive non-Mersenne prime which contains 2,357,207 digits: `28433*2^7830457+1`.\r\n\r\nFind the last ten digits of this prime number.", "\"z~k\"+*7+98v@\r\nv +***\"Gqz\"<.\r\n>1- \\2*\"(2\"v%\r\n|: \\%*:** :<*\r\n>$1+\"(2\":**:^", "Well this was a really easy one.\r\nWe simply multiply the number `28433` 7830457-times with two.\r\nAfter each multiplication we modulo the result with 2^10 to prevent an overflow and in the end we add one.\r\nThis is really simple (the program operates completely on the stack) and works perfectly as long as our interpreter uses at least 64bit numbers.\r\n(But this is a condition for a lot of programs I have written here)\r\n\r\nBut just for fun I have written an alternative version that uses only 32bit numbers.\r\nYou can find it on github under `Euler_Problem-097 (32bit).b93`, or here:\r\n\r\n~~~~~~~~~~~~\r\n\"}}2( \"****04003pp201p102p>04g01g2*`#v_v\r\nXv2*2g10**!%3*g20-2g10!-1%3*g102`2g10< 0\r\nX>-*03g+03p01g2*3%2-!01g2+# 02g*3%v    3\r\nXv*2g10+*2g20g10p30+g30*+* g1022*!< @.g<\r\nC>02g3*+01p02p            ^\r\n~~~~~~~~~~~~", 0, 164439636, 21091, 13, 5, 8739992577);
	Do(98, "Anagramic squares", "By replacing each of the letters in the word CARE with 1, 2, 9, and 6 respectively, \r\nwe form a square number: 1296 = 36^2. What is remarkable is that, \r\nby using the same digital substitutions, the anagram, RACE, \r\nalso forms a square number: 9216 = 96^2. \r\nWe shall call CARE (and RACE) a square anagram word pair and specify further \r\nthat leading zeroes are not permitted, \r\nneither may a different letter have the same digital value as another letter.\r\n\r\nUsing [words.txt](https://projecteuler.net/project/resources/p098_words.txt), \r\na 16K text file containing nearly two-thousand common English words, \r\nfind all the square anagram word pairs \r\n(a palindromic word is NOT considered to be an anagram of itself).\r\n\r\nWhat is the largest square number formed by any member of such a pair?\r\n\r\nNOTE: All anagrams formed must be contained in the given text file.", "vXXX #   #################################################################################################### #   A\r\n XXX #   #################################################################################################### #   ACCESS\r\n XX  #   #################################################################################################### #   ACROSS\r\n XX  #   #################################################################################################### #   ADDITIONAL\r\n XXX #   #################################################################################################### #   ADVISE\r\n X   #   #################################################################################################### #   AGAINST\r\n     #   #################################################################################################### #   AIM\r\n     #   #################################################################################################### #   ALRIGHT\r\n     #   #################################################################################################### #   ANALYSIS\r\n $   #   #################################################################################################### #   ANYBODY\r\n         #################################################################################################### #   APPEARANCE\r\n         #################################################################################################### #   ARGUE\r\n         #################################################################################################### #   ART\r\n         #################################################################################################### #   ASSET\r\n         #################################################################################################### #   ATTEMPT\r\n0        #################################################################################################### #   AVAILABLE\r\n1        #################################################################################################### #   BACKGROUND\r\n9        #################################################################################################### #   BASIC\r\np                           v             \\<          v        !:\\<                                           #   BED\r\n>0>:: 0\\ :9%82**\"r\"+\\9/  10p>:1+\\10gg:84*-#^_$$   0\\:!vv-1\\5< v*\\<+                                           #   BELONG\r\n                                                  v   <>:  >| >\\:|$                                           #   BIG\r\n  |                   -*\"&/\" :+1 p /\"d\"\\+9%\"d\": \\$_\"A\"-0\\: ^$>|  >^                                           #   BLOODY\r\n  $                                                      >:#<^>1\\^                          v         \\+1\\<   #   BOTH\r\n  >011p>11g1+21p             >11g:\"d\"%9+\\\"d\"/g 21g:\"d\"%9+\\\"d\"/g - #v_ 11g:9%82**\"r\"+\\9/10p0\\>:1+\\10gg84*-#^_v #   BRIDGE\r\n>\"&/\"*-|                     |!`*\"&/\"p12:+1g12    <                <   >\\*v >55+\\1-v    >\\*v >55+\\1-v       $ #   BURN\r\n^ p11:+1p/\"d\"\\+9%\"d\":\\\"#\":g11<                                         |:\\< |:<    <    |:\\< |:<    <         #   CAMPAIGN\r\n       9                                           v   p02:p010-1 \\ -1$<  ^$< ^   \\0 \\ $<  ^$< ^   \\0-1p13::<     ...\r\n       g                                           vp01g03_v#-g01:_v#- <                                          ...\r\n       .                                           >:30p:20 g\\/+2/: 30g^              vp01g03_v#-g01:_v#- <       ...\r\n       @                                                   >       >$30g1+12p 010p:20p>:30p:20 g\\/+2/: 30g^\r\n                                                  ^                              <            >       >$30gv\r\n                                           vp\\\"n\"\\\"|\":<+*297<vp\\5\\\"|\":<9p32*:g31_^#!`g22 p31:<g21       p22<\r\n                                           >:1-\\      |      >:1-\\    |   >        13g1+:13p ^\r\n         v-\"A\"g/9\\+g41+\"r\"**28%9:g11  <p41<-1g13     $<     ^        $<   ^                    < <\r\n                        v-1\\+55<  v*\\<|p41    -1:g41                                            <\r\n                        >:    >|  >\\:|                              >v                   >v\r\n         >24p 31g1-14g- 0\\:   ^>$:|  >   $23g\\/55+%34p  \"n\"24gg:\"|\"-|>34g-|>   534gg:\"|\"-|>24g-|\r\n                                  >1\\^                              >$    v              >$    v\r\n        v                     p410p510<                        vpg42\"n\"g43<       vpg435+\"A\"g42<\r\n                                                  >v           >           ^      >             ^\r\n        >21g:9%82**\"r\"+14g+\\9/g\"A\"-24p\"n\"24gg\"|\"-!|>           >>                                ^\r\n                                                  >\"n\"24gg14g+!|\r\n        |-g13p41:+1g41                       p51+gg42\"n\"*+55g51<\r\n                              >                                 ^\r\n        >15g23g`  15g19g` *  !|                                         > 15g19p v\r\n                              1                         >       >$30gv> |        >               ^\r\n                              5                 vp01g03_^#-g01:_^#- <:  >        ^\r\n                              g                 >:30p:20 g\\/+2/: 30g^*\r\n                                  >           >#^ #p #0 2 #<$      v\r\n                              >     :88*%\"9\"`#^_:88+%:9`#v_:2-#v_v   2\r\n                                       >     >     >     > #     >$>$0^\r\n                                  |!-8_^#-7:_^#-6:_^#-5:_^# -3:<     g\r\n                                             >     ^<   0 <^:p010 <^<-!\r\n                                  >:55+%:7-!#^_:3-!#^_2-!#^_:3%2-#^_^>^", "With this problem I tried a little bit differen methology with designing the problem.\r\nPrograms with massive (16k) input are always kind of ugly in befunge because \r\nall of the data must be in the program code, so I thought I can at least try a little bit around.\r\n\r\nIn this program I seperated the code, as much as I could, into independent subprograms.\r\nAll subprograms can use the [1,0]-[9,0] fields as temporary values, get their input \r\nfrom the stack and write their output also to the stack.\r\nThen I combined them together to build the whole program.\r\n\r\nAll the subprograms are in my [BefungePrograms git repo](https://gogs.mikescher.com/gitmirror/BefungePrograms)\r\n\r\nThis resulted in more readable code and (hopefully) snippets that I can reuse in other programs.\r\nBut the code doesn\'t compress as good (which nobody cares about in this problem, cause of the giant input size)\r\nand I\'m sure I could optimize it a lot by using more global state and shared variables etc.\r\n\r\nI think for my next programs I will continue as I did before and sometimes use independent code snippets\r\n(for example for the integer-squareroot function) but for the big main program I will write it all together.\r\n\r\nThe program works like so:\r\n\r\n1. First we calculate a \"palindromic hash value\" for each input word, this is a hash algorithm that \r\n   has no collisions as long as there are max five repeated letters in a word and has the same value for \r\n   palindroms.\r\n   Practically it is a 26-digit number in base-5 where each digit denotes the amount a specific letter occurs in our word.\r\n   We can not use a larger number than 5 for our base because then we would overflow our 64bit numbers.\r\n   \r\n2. Next we go through our palindromic list and search for palindroms (words with the same hash)\r\n   With some clever sorting tricks we could do this in `log2(n)`, but I will leave this as an \r\n   exercise for ther reader and and implement in naively in `n^2`\r\n\r\n3. For each word we iterate through all the squares with the correct digit count.\r\n   This means we start with `j`, where `j = 10^(len - 1)` and wnd with `k`, where `k = (10^len) - 1`\r\n   \r\n4. Now (for each square) we can generate the numeric value for word B with word A + square as our map.\r\n   When we generate our char->digit map (as an 26 element array) we also generate a digit->char map \r\n   to test if any digit is mapped to multiple different characters (a failure criteria)\r\n   \r\n5. Now we have square A and (possible) square B, with our optimized is-integer-squareroot function from problem 086 \r\n   we test if B is a square number. And if this is the case (and B is bigger than our current candidate) we set B\r\n   as our current result candidate\r\n   \r\n6. After we have done this for all pairs we can return (= print out) our current best candidate.\r\n\r\n\r\nUsed sub programs:\r\n - fixed_base_pow.b93\r\n - read_single_word.b93\r\n - get_palindromic_hash.b93\r\n - integer-squareroot-2.b93\r\n - is-squarenumber.b93\r\n - length_single_word.b93", 1, 145592567, 22714, 258, 199, 18769);
	Do(99, "Largest exponential", "Comparing two numbers written in index form like 2^11 and 3^7 is not difficult, \r\nas any calculator would confirm that 2^11 = 2048 < 3^7 = 2187.\r\n\r\nHowever, confirming that 632382^518061 > 519432^525806 would be much more difficult, \r\nas both numbers contain over three million digits.\r\n\r\nUsing [base_exp.txt](https://projecteuler.net/project/resources/p099_base_exp.txt), \r\na 22K text file containing one thousand lines with a base/exponent pair on each line, \r\ndetermine which line number has the greatest numerical value.\r\n\r\nNOTE: The first two lines in the file represent the numbers in the example given above.", "v$$$$$$                                           519432,525806\r\n XX  00v         $<                               632382,518061\r\n    v  <p15g11p16_^#`g16:p<                       78864,613712\r\n>0:5 1p vv               <1                       466580,530130\r\n v $ $  #<v+1g12+*+55\\p   12\\-*86<                780495,510032\r\n>#  > 0\"2\">:11gg:48*-0`!#^_:\",\"- |                525895,525320\r\n^p110p16< ^               # +1\\0$<                15991,714883\r\n   vp04+g04     <   vp06< +                       960290,502358\r\n : #>1-#v\\#/ #2<^      <: 1                       760018,511029\r\n !v<| :\\<***\"@}}\"g01<>$ ^ g                       166800,575487\r\nv_   20p10p01>:2*10g`| |>1^                       210884,564478\r\n$   >$30p0:4v^\\+1\\*2 <v<1                         555151,523163\r\n5 5>v  p05p0<     >>$40#+v                        681146,515199\r\n1 0#>030g\"}}@\"**`!|^ $< *g                        563395,522587\r\ng g|!`g03***\"@}}\"2<p < :g2                        738250,512126\r\n. +>1+30g:*\"}}@\"**/30^ $00                        923525,503780\r\n@ >50p30g2/30p20g50g>:!|6g                        595148,520429\r\n          > #2/#\\\\#-^#1<^<                        177108,572629\r\n                                                  750923,511482\r\n                                                  440902,532446\r\n                                                  881418,505504\r\n                                                  ...\r\n                                                  ...", "For every number we normalize the Exponentiation to base 2.\r\n(We search the equivalent Power `2^x`).\r\nAnd then we only compare the exponents with each other, practically this\r\nmeans we compare the length of the number in binary representation.\r\n\r\nWe chose 2 as our base because this way we don\'t have to worry too much about \r\nthe precision of our calculations (befunge has no native floating point values).\r\nIf we would have found two entries with the same (overall highest) exponent, we would \r\nhave to calculate the exponent to a higher precision, but fortunately this did not happen.\r\n\r\nFrom `b^e` we can get the normalized fraction `2^(e * log2(b))`.\r\nBut because befunge has no log2 operator we have to go through the dirty work of manually approximating log2.\r\n\r\nWe use [this][1] algorithm to calculate log2.\r\n\r\nFirst we calculate the integer part by simple searching the biggest number `2^n` where `2^n < b`\r\n\r\nThen the real part equals `log2(2^(-n) * b)`, because we don\'t want to caclulate with real numbers we \r\ninsert a Precision factor `F` (in this program we used a value of 1 million).\r\n\r\nNow `y = 2^-n * b` and `rp = log2(y)`. We calculate y by dividing b n-times with two.\r\n\r\nOur final result will be `r = n * e + rp * e`. We can already calculate `n*e`, the only missing part is `rp*e`, \r\nwhich we will call `exporp`.\r\n\r\nThen we repeat the following steps until the value of exporp is no longer changing:\r\n\r\n - count the number of times `m` we have to square `y` until `y >= 2` \r\n - `y = y^(2^m) / 2`\r\n - add `m` to `msum`, the collective sum of all calculated `m` values until now\r\n - divide `e` `msum`-times by two and add the result to `exporp`\r\n\r\nNow we have calculated `exporp`, our result is `r = n * e + exporp`.\r\n\r\nWith this method we can calculate the exponent of our normalized exponentiation.\r\nNext we simply iterate through the whole inpt and search the line number with the greatest base2-exponent.\r\n\r\n[1]: https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation", 1, 5072021, 1107, 63, 1000, 709);
	Do(100, "Arranged probability", "If a box contains twenty-one coloured discs, composed of fifteen blue discs and six red discs, \r\nand two discs were taken at random, it can be seen that the probability of taking two blue discs, \r\n`P(BB) = (15/21)x(14/20) = 1/2`.\r\n\r\nThe next such arrangement, for which there is exactly 50% chance of taking two blue discs at random, \r\nis a box containing eighty-five blue discs and thirty-five red discs.\r\n\r\nBy finding the first arrangement to contain over `10^12 = 1,000,000,000,000` discs in total, \r\ndetermine the number of blue discs that the box would contain.", "10v>012p >01g11g:01g3*\\4*+01p3*\\2*+11p02g12g:02g3*\\4*-0v\r\n##1^p110<|!`*:**\"@}}\"/4-g20-*g212-g10+*2g112p21-*2\\*3p2<\r\n##>p102p^>402g2*+12g2*+01g2*+11g2*-8/.@", "Let\'s say `b` is the number of blue disks, `r` the number of red disks \r\nand `n` is the total number.\r\nFrom the problem description we can infer this:\r\n~~~\r\nb+r = n                    (1)\r\n0 < b < n                  (2)\r\n0 < r < n                  (3)\r\nn > 10^12                  (4)\r\n(b/n)*((b-1)/(n-1)) = 1/2  (5)\r\n~~~\r\n\r\nNow we can user (1) and (2) to get a formula for `b` and `n`:\r\n\r\n~~~\r\n(b/n)*((b-1)/(n-1)) = 1/2\r\n2*b*(b-1) = n * (n-1)\r\n2*b^2 - 2*b = n^2 - n\r\n2 * (b^2 - b) = n^2-n\r\n0.5 * (2b)^2 - (2b) = (n)^2 - (n)\r\n2*(b^2) - 2b = (n)^2 - (n)\r\n\r\nb = 1/2 ( sqrt(2n^2 - 2n + 1) + 1 )\r\n~~~\r\n\r\nFor the last formula we search for integer solutions.\r\nWe can now either solve this manually with diophantine equations,\r\nor we ask [Wolfram|Alpha](www.wolframalpha.com/input/?i=2*b*b-2b+%3D+n*n-n).\r\nWhich gives us the following two formulas:\r\n\r\n~~~\r\ns = sqrt(2)\r\n\r\nb = (1/8) * (  2*(3-2*s)^m  +  s*(3-2*s)^m  +  2*(3+2*s)^m  -  s*(3+2*s)^m  +  4)\r\nn = (1/4) * (   -(3-2*s)^m  -  s*(3-2*s)^m  -    (3+2*s)^m  +  s*(3+2*s)^m  +  2)\r\n\r\nm element Z, m >= 0\r\n~~~\r\n\r\nWe can see both formulas contain the expression sqrt(2), which is not \r\nonly fractional but also irrational. Which is a problem with the strict integer\r\noperations in befunge.\r\n\r\nBut we can sidestep this by using a special number notation `r * 1 + s * sqrt(2)`.\r\nIn every step we calculate the \"real\" part of the number plus a multiple of `sqrt(2)`.\r\nThis is kinda like the common notation of [imaginary numbers](https://en.wikipedia.org/wiki/Imaginary_number).\r\n\r\nNow all we have to do is create algorithms for addition and multiplication in our new number format.\r\n\r\n~~~\r\n(r1 + s1 * sqrt(2)) + (r2 + s2 * sqrt(2)) = (r1+r2) + (s1+s2) * sqrt(2)\r\n(r1 + s1 * sqrt(2)) * (r2 + s2 * sqrt(2)) = (r1*r2+2*s1*s2) + (s1*r2+r1*s2) * sqrt(2)\r\n~~~\r\n\r\nNow we can use the formulas from Wolfram|Alpha until we find a value for `n > 10^12`.\r\n\r\nIn the end this problem wasn\'t that hard to code when all the preparations were done.\r\nAlso it\'s pretty fast.", 0, 1649, 0, 56, 3, 756872327473);
}

void Do(int Problemnumber, string Problemtitle, string Problemdescription, string Code, string Explanation, int AbbreviatedCode, long SolutionSteps, long SolutionTime, int SolutionWidth, int SolutionHeight, long SolutionValue)
{
	StringBuilder b = new StringBuilder();

	b.AppendLine($"<?php");
	b.AppendLine($"");
	b.AppendLine($"return ");
	b.AppendLine($"[");
	b.AppendLine($"\t'number'      => {Problemnumber},");
	b.AppendLine($"\t'title'       => '{ToLiteral(Problemtitle)}',");
	b.AppendLine($"\t'description' => function(){{ return file_get_contents(__DIR__ . '/euler_{Problemnumber:000}_description.md'); }},");
	b.AppendLine($"\t'code'        => function(){{ return file_get_contents(__DIR__ . '/euler_{Problemnumber:000}_code.txt');        }},");
	b.AppendLine($"\t'explanation' => function(){{ return file_get_contents(__DIR__ . '/euler_{Problemnumber:000}_explanation.md'); }},");
	b.AppendLine($"\t'url_euler'   => 'http://projecteuler.net/problem={Problemnumber:000}',");
	b.AppendLine($"\t'url_raw'     => 'https://raw.githubusercontent.com/Mikescher/Project-Euler_Befunge/master/processed/Euler_Problem-{Problemnumber:000}.b93',");
	b.AppendLine($"\t'url_github'  => 'https://github.com/Mikescher/Project-Euler_Befunge',");
	b.AppendLine($"\t'abbreviated' => {(AbbreviatedCode != 0).ToString().ToLower()},");
	b.AppendLine($"\t'steps'       => {SolutionSteps},");
	b.AppendLine($"\t'time'        => {SolutionTime},");
	b.AppendLine($"\t'width'       => {SolutionWidth},");
	b.AppendLine($"\t'height'      => {SolutionHeight},");
	b.AppendLine($"\t'value'       => {SolutionValue},");
	b.AppendLine($"];");

	File.WriteAllText(@"C:\Users\schwoerm\Desktop\M\hp\v4\www\rawdata\euler\" + $"euler_{Problemnumber:000}.php", b.ToString(), ENC);
	File.WriteAllText(@"C:\Users\schwoerm\Desktop\M\hp\v4\www\rawdata\euler\" + $"euler_{Problemnumber:000}_description.md", Problemdescription, ENC);
	File.WriteAllText(@"C:\Users\schwoerm\Desktop\M\hp\v4\www\rawdata\euler\" + $"euler_{Problemnumber:000}_code.txt", Code, ENC);
	File.WriteAllText(@"C:\Users\schwoerm\Desktop\M\hp\v4\www\rawdata\euler\" + $"euler_{Problemnumber:000}_explanation.md", Explanation, ENC);

}

private static string ToLiteral(string input)
{
	using (var writer = new StringWriter())
	{
		using (var provider = CodeDomProvider.CreateProvider("CSharp"))
		{
			provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
			var a = writer.ToString();
			return a.Substring(1, a.Length - 2);
		}
	}
}